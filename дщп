[applyBlockPatch] Updating codeAST: {blockId: 'mrpak:App.jsx:1190:1322:p', patch: {…}, hasCodeAST: true, isIntermediate: true}
AstBidirectional.js:420 [AstBidirectional] Element not found in AST: {elementId: 'mrpak:App.jsx:1190:1322:p', astType: 'File', hasProgram: true, programBodyLength: 2}
updateCodeAST @ AstBidirectional.js:420
(anonymous) @ RenderFile.jsx:484
(anonymous) @ RenderFile.jsx:901
handleMessage @ WebView.jsx:133
postMessage (async)
post @ VM3732 html;charset=utf-8,
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Component Preview</title>
    <script>
        window.__MRPAK_FILE_PATH__ = "/Users/deu/Projects/no-code-ui/tests/2-simple-react/App.jsx";
    </script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Ждем полной загрузки React перед инициализацией -->
    <script>
      // Функция для безопасной инициализации после загрузки React
      function initializeReactGlobals() {
        if (typeof React === 'undefined' || !React) {
          console.warn('[Init] React not loaded yet, retrying...');
          setTimeout(initializeReactGlobals, 50);
          return;
        }
        
        console.log('[Init] React loaded, initializing globals...');
        console.log('[React Hooks] Making all React hooks and APIs globally available...');
        
        // ========================================
        // БАЗОВЫЕ ХУКИ (React 16.8+)
        // ========================================
        if (React.useState) window.useState = React.useState;
          if (React.useEffect) window.useEffect = React.useEffect;
          if (React.useContext) window.useContext = React.useContext;
          
          // ========================================
          // ДОПОЛНИТЕЛЬНЫЕ ХУКИ
          // ========================================
          if (React.useReducer) window.useReducer = React.useReducer;
          if (React.useCallback) window.useCallback = React.useCallback;
          if (React.useMemo) window.useMemo = React.useMemo;
          if (React.useRef) window.useRef = React.useRef;
          if (React.useImperativeHandle) window.useImperativeHandle = React.useImperativeHandle;
          if (React.useLayoutEffect) window.useLayoutEffect = React.useLayoutEffect;
          if (React.useDebugValue) window.useDebugValue = React.useDebugValue;
          
          // ========================================
          // REACT 18+ ХУКИ
          // ========================================
          if (React.useId) window.useId = React.useId;
          if (React.useTransition) window.useTransition = React.useTransition;
          if (React.useDeferredValue) window.useDeferredValue = React.useDeferredValue;
          if (React.useSyncExternalStore) window.useSyncExternalStore = React.useSyncExternalStore;
          if (React.useInsertionEffect) window.useInsertionEffect = React.useInsertionEffect;
          
          // ========================================
          // ЭКСПЕРИМЕНТАЛЬНЫЕ ХУКИ (React 19+, если доступны)
          // ========================================
          if (React.use) window.use = React.use;
          if (React.useOptimistic) window.useOptimistic = React.useOptimistic;
          if (React.useFormStatus) window.useFormStatus = React.useFormStatus;
          if (React.useFormState) window.useFormState = React.useFormState;
          if (React.useActionState) window.useActionState = React.useActionState;
          
          // ========================================
          // REACT API - КОМПОНЕНТЫ И УТИЛИТЫ
          // ========================================
          if (React.createContext) window.createContext = React.createContext;
          if (React.forwardRef) window.forwardRef = React.forwardRef;
          if (React.memo) window.memo = React.memo;
          if (React.lazy) window.lazy = React.lazy;
          if (React.Suspense) window.Suspense = React.Suspense;
          if (React.Fragment) window.Fragment = React.Fragment;
          if (React.StrictMode) window.StrictMode = React.StrictMode;
          if (React.Profiler) window.Profiler = React.Profiler;
          
          // ========================================
          // КЛАССОВЫЕ КОМПОНЕНТЫ
          // ========================================
          if (React.Component) window.Component = React.Component;
          if (React.PureComponent) window.PureComponent = React.PureComponent;
          
          // ========================================
          // СОЗДАНИЕ ЭЛЕМЕНТОВ
          // ========================================
          if (React.createElement) window.createElement = React.createElement;
          if (React.cloneElement) window.cloneElement = React.cloneElement;
          if (React.createFactory) window.createFactory = React.createFactory;
          if (React.isValidElement) window.isValidElement = React.isValidElement;
          
          // ========================================
          // CHILDREN УТИЛИТЫ
          // ========================================
          if (React.Children) {
            window.Children = React.Children;
          }
          
          // ========================================
          // REACT 18+ CONCURRENT FEATURES
          // ========================================
          if (React.startTransition) window.startTransition = React.startTransition;
          
          // Подсчет доступных хуков
          const hooks = [
            'useState', 'useEffect', 'useContext', 'useReducer', 'useCallback',
            'useMemo', 'useRef', 'useImperativeHandle', 'useLayoutEffect', 'useDebugValue',
            'useId', 'useTransition', 'useDeferredValue', 'useSyncExternalStore', 'useInsertionEffect',
            'use', 'useOptimistic', 'useFormStatus', 'useFormState', 'useActionState'
          ].filter(hook => React[hook]);
        
        console.log('[React Hooks] Total hooks available:', hooks.length);
        console.log('[React Hooks] Available hooks:', hooks.join(', '));
        console.log('[Init] React globals initialized successfully');
      }
      
      // Запускаем инициализацию
      initializeReactGlobals();
    </script>
    
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: #f5f5f5;
        }
        #root {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .error {
            color: red;
            padding: 20px;
            background: #fee;
            border-radius: 4px;
            margin: 20px 0;
        }
        .info {
            color: #666;
            padding: 10px;
            background: #e3f2fd;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="info">
        <strong>React Component Preview</strong><br>
        Компонент загружается из выбранного файла...
    </div>
    <div id="root"></div>
    <script type="text/babel" data-type="module">
        // Делаем все React хуки доступными в Babel скрипте
        const React = window.React;
        
        // Базовые хуки (React 16.8+)
        const { 
          useState, useEffect, useContext, useReducer, useCallback, useMemo, useRef,
          useImperativeHandle, useLayoutEffect, useDebugValue
        } = React;
        
        // React 18+ хуки (безопасная деструктуризация)
        const useId = React.useId || (() => Math.random().toString(36));
        const useTransition = React.useTransition || (() => [false, (fn) => fn()]);
        const useDeferredValue = React.useDeferredValue || ((value) => value);
        const useSyncExternalStore = React.useSyncExternalStore;
        const useInsertionEffect = React.useInsertionEffect || useLayoutEffect;
        
        // React 19+ экспериментальные хуки (если доступны)
        const use = React.use;
        const useOptimistic = React.useOptimistic;
        const useFormStatus = React.useFormStatus;
        const useFormState = React.useFormState;
        const useActionState = React.useActionState;
        
        // React API
        const { 
          createContext, forwardRef, memo, lazy, Suspense, Fragment,
          Component, PureComponent, createElement, cloneElement, isValidElement,
          Children, StrictMode, Profiler, startTransition
        } = React;
        
        window.__modules__ = window.__modules__ || {};
        console.log('Before loading modules, window.__modules__ initialized');
        
        
        // Предварительная регистрация всех модулей (создаем пустые слоты)
        
        
        console.log('Pre-registered 0 module paths:', []);
        
        // Теперь загружаем модули (они заполнят предварительно зарегистрированные слоты)
        
        
        console.log('All modules loaded. Total modules:', Object.keys(window.__modules__ || {}).length);
        console.log('Registered module keys:', Object.keys(window.__modules__ || {}));
    
        
        console.log('Available modules:', Object.keys(window.__modules__ || {}));
        
        try {
            /**
 * Простой однофайловый React компонент для тестирования ReactFramework
 */
function App() {
  const [count, setCount] = useState(0);
  const [message, setMessage] = useState('');

  const handleClick = () => {
    setCount(count + 1);
    setMessage(`Кнопка нажата ${count + 1} раз`);

  };

  return (
    <div style={{
      fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
      background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
      minHeight: '100vh',
      padding: '20px',
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center'
    }} data-no-code-ui-id="mrpak:App.jsx:369:671:div">
      <div style={{
        maxWidth: '600px',
        background: 'white',
        borderRadius: '12px',
        padding: '32px',
        boxShadow: '0 10px 40px rgba(0,0,0,0.2)'
      }} data-no-code-ui-id="mrpak:App.jsx:678:861:div">
        

        <div style={{
          background: '#f8f9fa',
          borderRadius: '8px',
          padding: '20px',
          margin: '16px 0',
          border: '2px solid #e9ecef'
        }} data-no-code-ui-id="mrpak:App.jsx:880:1062:div">
          <h2 style={{ color: '#764ba2', marginTop: 0, position: "relative", left: 3.5, top: -61.922 }} data-no-code-ui-id="mrpak:App.jsx:1073:1167:h2">Счетчик</h2>
          <p style={{ color: '#495057', fontSize: '18px', position: "relative", left: 25, top: -2.0780000000000003, width: 125, height: 80 }} data-no-code-ui-id="mrpak:App.jsx:1190:1322:p">
            Текущее значение: <strong data-no-code-ui-id="mrpak:App.jsx:1353:1361:strong">{count}</strong>
          </p>
          <button
            onClick={handleClick}
            style={{
              background: '#667eea',
              color: 'white',
              border: 'none',
              padding: '12px 24px',
              borderRadius: '6px',
              fontSize: '16px',
              cursor: 'pointer',
              transition: 'all 0.3s'
            }} data-no-code-ui-id="mrpak:App.jsx:1403:1751:button">

            Увеличить счетчик
          </button>
          {message &&
          <p style={{
            marginTop: '16px',
            color: '#28a745',
            fontWeight: '600'
          }} data-no-code-ui-id="mrpak:App.jsx:1835:1951:p">
              {message}
            </p>
          }
        </div>

        <div style={{
          background: '#f8f9fa',
          borderRadius: '8px',
          padding: '20px',
          margin: '16px 0',
          border: '2px solid #e9ecef'
        }} data-no-code-ui-id="mrpak:App.jsx:2029:2211:div">
          <h3 style={{ color: '#495057', marginTop: 0 }} data-no-code-ui-id="mrpak:App.jsx:2222:2269:h3">О тесте</h3>
          <p style={{ color: '#6c757d', lineHeight: '1.6' }} data-no-code-ui-id="mrpak:App.jsx:2292:2343:p">
            Этот компонент тестирует ReactFramework: инструментацию JSX,
            обработку зависимостей, применение стилей и операции с элементами.
          </p>
        </div>
      </div>
    </div>);

}
            
            let Component = null;
            if (typeof App !== 'undefined') {
                Component = App;
              }
            
            if (Component) {
                const root = ReactDOM.createRoot(document.getElementById('root'));
                root.render(React.createElement(Component));
                
                setTimeout(() => {
                  const rootElement = document.getElementById('root');
                  const filePath = window.__MRPAK_FILE_PATH__ || '';
                  
                  if (window.__MRPAK_BUILD_TREE__ && typeof window.__MRPAK_BUILD_TREE__ === 'function') {
                    window.__MRPAK_BUILD_TREE__();
                  }
                  
                  const observer = new MutationObserver((mutations) => {
                    const rootElement = document.getElementById('root');
                    if (rootElement) {
                      if (typeof buildTree === 'function') {
                        buildTree();
                      }
                    }
                  });
                  
                  observer.observe(document.body, {
                    childList: true,
                    subtree: true
                  });
                }, 100);
            } else {
                const foundComponents = ["function"];
                const errorMsg = foundComponents.length > 0 
                  ? 'Найдены компоненты: ' + foundComponents.join(', ') + '. Но не удалось их использовать для рендеринга.'
                  : 'Не найден компонент для рендеринга.';
                document.getElementById('root').innerHTML = '<div class="error">' + errorMsg + '</div>';
            }
        } catch (error) {
            document.getElementById('root').innerHTML = '<div class="error"><strong>Ошибка выполнения:</strong><br>' + error.message + '</div>';
            console.error('React execution error:', error);
        }
    </script>

      <style>
        [data-no-code-ui-id].mrpak-selected, [data-mrpak-id].mrpak-selected { outline: 2px solid #667eea !important; outline-offset: 2px; }
        .mrpak-hint { position: fixed; z-index: 9999; bottom: 10px; right: 10px; background: rgba(15,23,42,0.85); color: #fff; padding: 8px 10px; border-radius: 8px; font: 12px/1.2 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif; }
        
      </style>
      <script>
        (function() {
          const EDIT_MODE = false;
          const ATTR_NEW = 'data-no-code-ui-id';
          const ATTR_OLD = 'data-mrpak-id';
          const SEL_ALL = '[data-no-code-ui-id],[data-mrpak-id]';
          const getId = (el) => {
            try {
              return (el && el.getAttribute && (el.getAttribute(ATTR_NEW) || el.getAttribute(ATTR_OLD))) || null;
            } catch (e) {
              return null;
            }
          };
          const ensureId = (el) => {
            try {
              if (!el || !el.getAttribute || !el.setAttribute) return null;
              const id = getId(el);
              if (id) {
                if (!el.getAttribute(ATTR_NEW)) el.setAttribute(ATTR_NEW, id);
                if (el.getAttribute(ATTR_OLD)) el.removeAttribute(ATTR_OLD);
                return id;
              }
              const tmp = 'mrpak:temp:' + Date.now() + ':' + Math.random().toString(16).slice(2, 8);
              el.setAttribute(ATTR_NEW, tmp);
              return tmp;
            } catch (e) {
              return null;
            }
          };
          const byIdSelector = (id) => {
            const safe = String(id || '').replace(/"/g,'');
            return '[data-no-code-ui-id="' + safe + '"],[data-mrpak-id="' + safe + '"]';
          };
          const MSG_SELECT = 'MRPAK_SELECT';
          const MSG_APPLY = 'MRPAK_APPLY';
          const MSG_TREE = 'MRPAK_TREE';
          const MSG_READY = 'MRPAK_READY';
          const MSG_STYLE_SNAPSHOT = 'MRPAK_STYLE_SNAPSHOT';
          const MSG_TEXT_SNAPSHOT = 'MRPAK_TEXT_SNAPSHOT';
          const MSG_DROP_TARGET = 'MRPAK_DROP_TARGET';
          const CMD_SELECT = 'MRPAK_CMD_SELECT';
          const CMD_INSERT = 'MRPAK_CMD_INSERT';
          const CMD_DELETE = 'MRPAK_CMD_DELETE';
          const CMD_SET_STYLE = 'MRPAK_CMD_SET_STYLE';
          const CMD_REQ_STYLE = 'MRPAK_CMD_REQUEST_STYLE_SNAPSHOT';
          const CMD_REPARENT = 'MRPAK_CMD_REPARENT';
          const CMD_SET_MOVE_MODE = 'MRPAK_CMD_SET_MOVE_MODE';
          const CMD_SET_TEXT = 'MRPAK_CMD_SET_TEXT';
          const CMD_REQ_TEXT = 'MRPAK_CMD_REQUEST_TEXT_SNAPSHOT';
          const CMD_START_DRAG = 'MRPAK_CMD_START_DRAG';
          const CMD_END_DRAG = 'MRPAK_CMD_END_DRAG';
          let selected = null;
          let lastSelectedId = null;
          let moveMode = 'absolute'; // absolute | relative | grid8
          let gridStep = 8;
          let dragging = null; // {sourceId}
          let dropTarget = null;

          const snap = (v) => {
            if (moveMode !== 'grid8') return v;
            const step = gridStep || 8;
            return Math.round(v / step) * step;
          };

          const getOffsetParent = (el) => el && (el.offsetParent || el.parentElement || document.body);

          const pxToNum = (s) => {
            const m = String(s || '').match(/(-?\d+(?:\.\d+)?)px/);
            return m ? Number(m[1]) : 0;
          };

          function post(type, payload) {
            try {
              window.parent && window.parent.postMessage({ type, ...payload }, '*');
            } catch (e) {}
          }

          function buildTree() {
            const nodes = {};
            const rootIds = [];
            const all = Array.from(document.querySelectorAll(SEL_ALL));
            
            // Сначала создаем все узлы
            for (const el of all) {
              const id = ensureId(el);
              if (!id) continue;
              
              // Ищем родителя более точно: идем вверх по DOM дереву и ищем ближайший элемент с id-атрибутом
              let parentEl = null;
              let current = el.parentElement;
              while (current && current !== document.body && current !== document.documentElement) {
                if (current.hasAttribute && (current.hasAttribute(ATTR_NEW) || current.hasAttribute(ATTR_OLD))) {
                  parentEl = current;
                  break;
                }
                current = current.parentElement;
              }
              
              const parentId = parentEl ? getId(parentEl) : null;
              nodes[id] = { id, tagName: el.tagName, parentId, childIds: [] };
            }
            
            // Определяем детей и корневые элементы
            for (const id of Object.keys(nodes)) {
              const p = nodes[id].parentId;
              if (p && nodes[p]) {
                nodes[p].childIds.push(id);
              } else {
                rootIds.push(id);
              }
            }
            
            // Упорядочиваем children по порядку в DOM
            for (const id of Object.keys(nodes)) {
              const el = document.querySelector(byIdSelector(id));
              if (!el) continue;
              
              const parentEl = el.parentElement;
              if (parentEl) {
                // Ищем родителя с id-атрибутом
                let parentWithId = null;
                let current = parentEl;
                while (current && current !== document.body && current !== document.documentElement) {
                  if (current.hasAttribute && (current.hasAttribute(ATTR_NEW) || current.hasAttribute(ATTR_OLD))) {
                    parentWithId = current;
                    break;
                  }
                  current = current.parentElement;
                }
                
                if (parentWithId) {
                  const pid = ensureId(parentWithId);
                  if (pid && nodes[pid]) {
                    // Получаем прямых детей с id-атрибутом в порядке DOM
                    const directChildren = Array.from(parentWithId.children)
                      .filter(child => child && child.hasAttribute && (child.hasAttribute(ATTR_NEW) || child.hasAttribute(ATTR_OLD)))
                      .map(child => ensureId(child))
                      .filter(Boolean);
                    nodes[pid].childIds = directChildren;
                  }
                }
              }
            }
            
            post(MSG_TREE, { tree: { nodes, rootIds } });
          }
          
          // Делаем buildTree доступной глобально для вызова из скрипта React
          window.__MRPAK_BUILD_TREE__ = buildTree;

          function clearSelected() {
            try {
              if (selected) selected.classList.remove('mrpak-selected');
            } catch(e) {}
            selected = null;
          }

          function selectEl(el) {
            if (!el) return;
            clearSelected();
            selected = el;
            try { selected.classList.add('mrpak-selected'); } catch(e) {}
            const id = ensureId(selected);
            lastSelectedId = id;
            const rect = selected.getBoundingClientRect();
            post(MSG_SELECT, { id, meta: { tagName: selected.tagName, rect: { x: rect.x, y: rect.y, w: rect.width, h: rect.height } } });
            buildTree();
            // отправляем снапшот inline style, чтобы UI мог показать базовые стили
            try {
              const inline = selected.getAttribute('style') || '';
              const cs = window.getComputedStyle(selected);
              const computed = {
                position: cs.getPropertyValue('position'),
                left: cs.getPropertyValue('left'),
                top: cs.getPropertyValue('top'),
                width: cs.getPropertyValue('width'),
                height: cs.getPropertyValue('height'),
                color: cs.getPropertyValue('color'),
                backgroundColor: cs.getPropertyValue('background-color'),
                fontSize: cs.getPropertyValue('font-size'),
                display: cs.getPropertyValue('display'),
                flex: cs.getPropertyValue('flex'),
                justifyContent: cs.getPropertyValue('justify-content'),
                alignItems: cs.getPropertyValue('align-items'),
                margin: cs.getPropertyValue('margin'),
                padding: cs.getPropertyValue('padding'),
              };
              post(MSG_STYLE_SNAPSHOT, { id, inlineStyle: inline, computedStyle: computed });
              const txt = selected.innerText || '';
              post(MSG_TEXT_SNAPSHOT, { id, text: txt });
            } catch(e) {}
          }

          // В режиме редактора делаем контент "неинтерактивным":
          // - гасим клики/submit/клавиатурные активации по интерактивным элементам
          // - при этом сохраняем возможность выбирать блоки кликом и двигать Shift/Alt+Drag
          function isInteractive(el) {
            if (!el || el.nodeType !== 1) return false;
            const tag = (el.tagName || '').toUpperCase();
            if (['A','BUTTON','INPUT','SELECT','TEXTAREA','LABEL','FORM','SUMMARY'].includes(tag)) return true;
            if (el.hasAttribute && el.hasAttribute('contenteditable')) return true;
            const role = el.getAttribute ? (el.getAttribute('role') || '') : '';
            if (role === 'button' || role === 'link' || role === 'checkbox' || role === 'switch') return true;
            if (typeof el.onclick === 'function') return true;
            return false;
          }

          // Hover для drop target при перетаскивании (режим reparent)
          document.addEventListener('mousemove', (ev) => {
            if (!dragging || !dragging.sourceId || dragging.mode !== 'reparent') return;
            const el = ev.target && ev.target.closest ? ev.target.closest(SEL_ALL) : null;
            const sid = dragging.sourceId;
            if (el) {
              const id = ensureId(el);
              if (id && id !== sid) {
                dropTarget = id;
                post(MSG_DROP_TARGET, { sourceId: sid, targetId: id });
              }
            } else {
              dropTarget = null;
              post(MSG_DROP_TARGET, { sourceId: sid, targetId: null });
            }
          }, true);

          // Блокируем submit форм только в режиме редактора
          if (EDIT_MODE) {
            document.addEventListener('submit', (ev) => {
              try {
                ev.preventDefault();
                ev.stopPropagation();
                ev.stopImmediatePropagation();
              } catch(e) {}
            }, true);
          }

          // Блокируем все события на интерактивных элементах только в режиме редактора
          const blockInteractiveEvents = (ev) => {
            if (!EDIT_MODE) return;
            const t = ev.target;
            if (!t) return;
            // Проверяем, является ли элемент интерактивным
            if (isInteractive(t) || (t.closest && t.closest('a,button,input,select,textarea,label,form,[role=button],[role=link],[role=checkbox],[role=switch],[contenteditable]'))) {
              try {
                ev.preventDefault();
                ev.stopPropagation();
                ev.stopImmediatePropagation();
                // Если у интерактивного элемента есть id-атрибут, выбираем его напрямую
                if (t.hasAttribute && (t.hasAttribute(ATTR_NEW) || t.hasAttribute(ATTR_OLD))) {
                  selectEl(t);
                  return;
                }
                // Иначе выбираем родительский блок
                const block = t.closest(SEL_ALL);
                if (block && block !== t) {
                  selectEl(block);
                }
              } catch(e) {}
            }
          };

          // Блокируем все события на интерактивных элементах (кроме mousedown, который обрабатывается отдельно) только в режиме редактора
          if (EDIT_MODE) {
            document.addEventListener('mouseup', blockInteractiveEvents, true);
            document.addEventListener('dblclick', blockInteractiveEvents, true);
            document.addEventListener('change', blockInteractiveEvents, true);
            document.addEventListener('input', blockInteractiveEvents, true);
            document.addEventListener('focus', blockInteractiveEvents, true);
            document.addEventListener('blur', blockInteractiveEvents, true);
            document.addEventListener('keydown', (ev) => {
              const t = ev.target;
              if (t && (isInteractive(t) || (t.closest && t.closest('a,button,input,select,textarea,[role=button],[role=link],[contenteditable]')))) {
                try {
                  ev.preventDefault();
                  ev.stopPropagation();
                  ev.stopImmediatePropagation();
                  // Если у интерактивного элемента есть id-атрибут, выбираем его напрямую
                  if (t.hasAttribute && (t.hasAttribute(ATTR_NEW) || t.hasAttribute(ATTR_OLD))) {
                    selectEl(t);
                    return;
                  }
                  // Иначе выбираем родительский блок
                  const block = t.closest(SEL_ALL);
                  if (block && block !== t) {
                    selectEl(block);
                  }
                } catch(e) {}
              }
            }, true);
            document.addEventListener('keyup', blockInteractiveEvents, true);
            document.addEventListener('keypress', blockInteractiveEvents, true);
          }
          
          // Обработка клика для выбора блоков (только в режиме редактора)
          document.addEventListener('click', (ev) => {
            if (!EDIT_MODE) return; // В preview режиме не обрабатываем клики для выбора
            
            const t = ev.target;
            // Если это интерактивный элемент, обрабатываем его
            if (t && (isInteractive(t) || (t.closest && t.closest('a,button,input,select,textarea,label,form,[role=button],[role=link],[contenteditable]')))) {
              try {
                ev.preventDefault();
                ev.stopPropagation();
                ev.stopImmediatePropagation();
                // Если у интерактивного элемента есть id-атрибут, выбираем его напрямую
                if (t.hasAttribute && (t.hasAttribute(ATTR_NEW) || t.hasAttribute(ATTR_OLD))) {
                  selectEl(t);
                  return;
                }
                // Иначе выбираем родительский блок
                const block = t.closest(SEL_ALL);
                if (block && block !== t) {
                  selectEl(block);
                  return;
                }
              } catch(e) {}
            }
            // Если это не интерактивный элемент, обрабатываем как обычный клик для выбора блока
            const el = ev.target && ev.target.closest ? ev.target.closest(SEL_ALL) : null;
            if (!el) return;
            try {
              ev.preventDefault();
              ev.stopPropagation();
            } catch(e) {}
            selectEl(el);
          }, true);

          // Shift+Drag: перенос (MVP -> position:absolute + left/top/width/height)
          // Этот обработчик также блокирует интерактивные элементы (только в режиме редактора)
          let drag = null;
          document.addEventListener('mousedown', (ev) => {
            if (!EDIT_MODE) return; // В preview режиме не обрабатываем
            
            const t = ev.target;
            // Если это интерактивный элемент, обрабатываем его
            if (t && (isInteractive(t) || (t.closest && t.closest('a,button,input,select,textarea,label,form,[role=button],[role=link],[contenteditable]')))) {
              try {
                ev.preventDefault();
                ev.stopPropagation();
                ev.stopImmediatePropagation();
                
                // Если у интерактивного элемента есть id-атрибут, используем его
                let targetEl = t;
                let targetId = null;
                if (t.hasAttribute && (t.hasAttribute(ATTR_NEW) || t.hasAttribute(ATTR_OLD))) {
                  targetId = getId(t);
                } else {
                  // Иначе ищем родительский блок
                  const block = t.closest(SEL_ALL);
                  if (block && block !== t) {
                    targetEl = block;
                    targetId = getId(block);
                  }
                }
                
                if (targetId) {
                  selectEl(targetEl);
                  // Если это Shift/Ctrl/Alt + клик, обрабатываем как drag
                  if (ev.ctrlKey || ev.metaKey) {
                    dragging = { sourceId: targetId, mode: 'reparent' };
                    post(MSG_DROP_TARGET, { sourceId: targetId, targetId: null });
                    return;
                  } else if (ev.shiftKey || ev.altKey) {
                    dragging = { sourceId: targetId, mode: ev.altKey ? 'resize' : 'move' };
                    const startRect = targetEl.getBoundingClientRect();
                    drag = {
                      mode: ev.altKey ? 'resize' : 'move',
                      sx: ev.clientX,
                      sy: ev.clientY,
                      rect: startRect,
                    };
                    return;
                  }
                }
                return;
              } catch(e) {}
            }
            
            const el = ev.target && ev.target.closest ? ev.target.closest(SEL_ALL) : null;
            if (!el) return;
            
            // Ctrl/Cmd + drag => reparent drag
            if (ev.ctrlKey || ev.metaKey) {
              ev.preventDefault();
              ev.stopPropagation();
              const id = ensureId(el);
              dragging = { sourceId: id, mode: 'reparent' };
              selectEl(el);
              post(MSG_DROP_TARGET, { sourceId: id, targetId: null });
              return;
            }
            if (!selected) return;
            if (!ev.shiftKey && !ev.altKey) return;
            ev.preventDefault();
            ev.stopPropagation();
            const id = ensureId(selected);
            dragging = { sourceId: id, mode: ev.altKey ? 'resize' : 'move' };
            const startRect = selected.getBoundingClientRect();
            drag = {
              mode: ev.altKey ? 'resize' : 'move',
              sx: ev.clientX,
              sy: ev.clientY,
              rect: startRect,
            };
          }, true);

          document.addEventListener('mousemove', (ev) => {
            if (!drag || !selected) return;
            const dx = ev.clientX - drag.sx;
            const dy = ev.clientY - drag.sy;
            const id = ensureId(selected);
            
            if (drag.mode === 'move') {
              selected.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
              
              // Отправляем промежуточные изменения при каждом движении
              const parent = getOffsetParent(selected);
              const parentRect = parent && parent.getBoundingClientRect ? parent.getBoundingClientRect() : { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight };
              const ps = parent ? window.getComputedStyle(parent) : null;
              const padLeft = ps ? parseFloat(ps.getPropertyValue('padding-left')) || 0 : 0;
              const padTop = ps ? parseFloat(ps.getPropertyValue('padding-top')) || 0 : 0;
              const padRight = ps ? parseFloat(ps.getPropertyValue('padding-right')) || 0 : 0;
              const padBottom = ps ? parseFloat(ps.getPropertyValue('padding-bottom')) || 0 : 0;
              
              if (moveMode === 'relative') {
                const cs = window.getComputedStyle(selected);
                const baseLeft = cs.left === 'auto' ? 0 : pxToNum(cs.left);
                const baseTop = cs.top === 'auto' ? 0 : pxToNum(cs.top);
                const left = snap(baseLeft + dx);
                const top = snap(baseTop + dy);
                
                if ('react' === 'html') {
                  post(MSG_APPLY, { id, patch: { position: 'relative', left: left + 'px', top: top + 'px' }, isIntermediate: true });
                } else {
                  post(MSG_APPLY, { id, patch: { position: 'relative', left: left, top: top }, isIntermediate: true });
                }
              } else {
                const startLeft = drag.rect.left - parentRect.left - padLeft;
                const startTop = drag.rect.top - parentRect.top - padTop;
                
                let left = snap(startLeft + dx);
                let top = snap(startTop + dy);
                
                const maxLeft = parentRect.width - padRight - snap(drag.rect.width);
                const maxTop = parentRect.height - padBottom - snap(drag.rect.height);
                const minLeft = padLeft;
                const minTop = padTop;
                left = Math.min(Math.max(left, minLeft), maxLeft);
                top = Math.min(Math.max(top, minTop), maxTop);
                
                if ('react' === 'html') {
                  post(MSG_APPLY, { id, patch: { position: 'absolute', left: left + 'px', top: top + 'px' }, isIntermediate: true });
                } else {
                  post(MSG_APPLY, { id, patch: { position: 'absolute', left: left, top: top }, isIntermediate: true });
                }
              }
            } else {
              const w = snap(Math.max(1, drag.rect.width + dx));
              const h = snap(Math.max(1, drag.rect.height + dy));
              selected.style.width = w + 'px';
              selected.style.height = h + 'px';
              
              // Отправляем промежуточные изменения при каждом движении
              if ('react' === 'html') {
                post(MSG_APPLY, { id, patch: { width: w + 'px', height: h + 'px' }, isIntermediate: true });
              } else {
                post(MSG_APPLY, { id, patch: { width: w, height: h }, isIntermediate: true });
              }
            }
          }, true);

          // Touch события для мобильных устройств
          document.addEventListener('touchmove', (ev) => {
            if (!drag || !selected) return;
            const touch = ev.touches[0];
            if (!touch) return;
            const dx = touch.clientX - drag.sx;
            const dy = touch.clientY - drag.sy;
            const id = ensureId(selected);
            
            if (drag.mode === 'move') {
              selected.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
              
              // Отправляем промежуточные изменения при каждом движении
              const parent = getOffsetParent(selected);
              const parentRect = parent && parent.getBoundingClientRect ? parent.getBoundingClientRect() : { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight };
              const ps = parent ? window.getComputedStyle(parent) : null;
              const padLeft = ps ? parseFloat(ps.getPropertyValue('padding-left')) || 0 : 0;
              const padTop = ps ? parseFloat(ps.getPropertyValue('padding-top')) || 0 : 0;
              const padRight = ps ? parseFloat(ps.getPropertyValue('padding-right')) || 0 : 0;
              const padBottom = ps ? parseFloat(ps.getPropertyValue('padding-bottom')) || 0 : 0;
              
              if (moveMode === 'relative') {
                const cs = window.getComputedStyle(selected);
                const baseLeft = cs.left === 'auto' ? 0 : pxToNum(cs.left);
                const baseTop = cs.top === 'auto' ? 0 : pxToNum(cs.top);
                const left = snap(baseLeft + dx);
                const top = snap(baseTop + dy);
                
                if ('react' === 'html') {
                  post(MSG_APPLY, { id, patch: { position: 'relative', left: left + 'px', top: top + 'px' }, isIntermediate: true });
                } else {
                  post(MSG_APPLY, { id, patch: { position: 'relative', left: left, top: top }, isIntermediate: true });
                }
              } else {
                const startLeft = drag.rect.left - parentRect.left - padLeft;
                const startTop = drag.rect.top - parentRect.top - padTop;
                
                let left = snap(startLeft + dx);
                let top = snap(startTop + dy);
                
                const maxLeft = parentRect.width - padRight - snap(drag.rect.width);
                const maxTop = parentRect.height - padBottom - snap(drag.rect.height);
                const minLeft = padLeft;
                const minTop = padTop;
                left = Math.min(Math.max(left, minLeft), maxLeft);
                top = Math.min(Math.max(top, minTop), maxTop);
                
                if ('react' === 'html') {
                  post(MSG_APPLY, { id, patch: { position: 'absolute', left: left + 'px', top: top + 'px' }, isIntermediate: true });
                } else {
                  post(MSG_APPLY, { id, patch: { position: 'absolute', left: left, top: top }, isIntermediate: true });
                }
              }
            } else {
              const w = snap(Math.max(1, drag.rect.width + dx));
              const h = snap(Math.max(1, drag.rect.height + dy));
              selected.style.width = w + 'px';
              selected.style.height = h + 'px';
              
              // Отправляем промежуточные изменения при каждом движении
              if ('react' === 'html') {
                post(MSG_APPLY, { id, patch: { width: w + 'px', height: h + 'px' }, isIntermediate: true });
              } else {
                post(MSG_APPLY, { id, patch: { width: w, height: h }, isIntermediate: true });
              }
            }
          }, { passive: false });

          document.addEventListener('mouseup', (ev) => {
            // reparent drag (Ctrl/Cmd + drag)
            if (dragging && dragging.mode === 'reparent') {
              if (dropTarget && dragging.sourceId && dropTarget !== dragging.sourceId) {
                post(MSG_APPLY, { id: dragging.sourceId, patch: { __reparentTo: dropTarget } });
              }
              dragging = null;
              dropTarget = null;
              drag = null;
              return;
            }

            if (!drag || !selected) return;
            const dx = ev.clientX - drag.sx;
            const dy = ev.clientY - drag.sy;
            const id = ensureId(selected);

            // координаты родителя и padding для ограничения
            const parent = getOffsetParent(selected);
            const parentRect = parent && parent.getBoundingClientRect ? parent.getBoundingClientRect() : { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight };
            const ps = parent ? window.getComputedStyle(parent) : null;
            const padLeft = ps ? parseFloat(ps.getPropertyValue('padding-left')) || 0 : 0;
            const padTop = ps ? parseFloat(ps.getPropertyValue('padding-top')) || 0 : 0;
            const padRight = ps ? parseFloat(ps.getPropertyValue('padding-right')) || 0 : 0;
            const padBottom = ps ? parseFloat(ps.getPropertyValue('padding-bottom')) || 0 : 0;
            const scrollLeft = parent ? (parent.scrollLeft || 0) : 0;
            const scrollTop = parent ? (parent.scrollTop || 0) : 0;

            if (drag.mode === 'move') {
              selected.style.transform = '';

              if (moveMode === 'relative') {
                const cs = window.getComputedStyle(selected);
                const baseLeft = cs.left === 'auto' ? 0 : pxToNum(cs.left);
                const baseTop = cs.top === 'auto' ? 0 : pxToNum(cs.top);
                const left = snap(baseLeft + dx);
                const top = snap(baseTop + dy);
                selected.style.position = 'relative';
                selected.style.left = left + 'px';
                selected.style.top = top + 'px';

                if ('react' === 'html') {
                  post(MSG_APPLY, { id, patch: { position: 'relative', left: left + 'px', top: top + 'px' }, isIntermediate: false });
                } else {
                  post(MSG_APPLY, { id, patch: { position: 'relative', left: left, top: top }, isIntermediate: false });
                }
              } else {
                // absolute с ограничением по padding-box
                const startLeft = drag.rect.left - parentRect.left - padLeft;
                const startTop = drag.rect.top - parentRect.top - padTop;
                
                let left = snap(startLeft + dx);
                let top = snap(startTop + dy);

                // Ограничиваем позицию padding-box родителя
                const maxLeft = parentRect.width - padRight - snap(drag.rect.width);
                const maxTop = parentRect.height - padBottom - snap(drag.rect.height);
                const minLeft = padLeft;
                const minTop = padTop;
                left = Math.min(Math.max(left, minLeft), maxLeft);
                top = Math.min(Math.max(top, minTop), maxTop);

                selected.style.position = 'absolute';
                selected.style.left = left + 'px';
                selected.style.top = top + 'px';

                if ('react' === 'html') {
                  post(MSG_APPLY, { id, patch: { position: 'absolute', left: left + 'px', top: top + 'px' }, isIntermediate: false });
                } else {
                  post(MSG_APPLY, { id, patch: { position: 'absolute', left: left, top: top }, isIntermediate: false });
                }
              }
            } else {
              const w = snap(Math.max(1, drag.rect.width + dx));
              const h = snap(Math.max(1, drag.rect.height + dy));
              // constrain size чтобы не выходить за padding-box справа/снизу
              const maxW = parentRect.width - padLeft - padRight;
              const maxH = parentRect.height - padTop - padBottom;
              const cw = Math.min(w, maxW);
              const ch = Math.min(h, maxH);

              selected.style.width = cw + 'px';
              selected.style.height = ch + 'px';
              if ('react' === 'html') {
                post(MSG_APPLY, { id, patch: { width: cw + 'px', height: ch + 'px' }, isIntermediate: false });
              } else {
                post(MSG_APPLY, { id, patch: { width: cw, height: ch }, isIntermediate: false });
              }
            }

            drag = null;
            dragging = null;
            dropTarget = null;
          }, true);

          // Подсказка
          try {
            const hint = document.createElement('div');
            hint.className = 'mrpak-hint';
            hint.textContent = 'MRPAK Editor: клик = выбрать, Shift+Drag = переместить, Alt+Drag = изменить размер';
            document.body.appendChild(hint);
          } catch(e) {}

          // Команды из UI (локальные изменения)
          window.addEventListener('message', (event) => {
            const data = event && event.data;
            if (!data || typeof data !== 'object') return;
            try {
              if (data.type === CMD_SELECT && data.id) {
                const el = document.querySelector(byIdSelector(String(data.id)));
                if (el) selectEl(el);
                return;
              }
              if (data.type === CMD_SET_STYLE && data.id) {
                console.log('[iframe CMD_SET_STYLE] Получена команда:', {
                  id: data.id,
                  patch: data.patch,
                  hasPatch: !!data.patch
                });
                const el = document.querySelector(byIdSelector(String(data.id)));
                if (!el) {
                  console.warn('[iframe CMD_SET_STYLE] Элемент не найден:', data.id);
                  return;
                }
                const patch = data.patch || {};
                console.log('[iframe CMD_SET_STYLE] Применяю патч:', patch);
                for (const k in patch) {
                  const v = patch[k];
                  if (k.includes('-')) {
                    if (v === null || v === undefined || v === '') {
                      // Удаляем свойство, если значение пустое
                      el.style.removeProperty(k);
                    } else {
                      el.style.setProperty(k, String(v));
                    }
                  } else {
                    // DOM style: camelCase
                    try { 
                      if (v === null || v === undefined || v === '') {
                        el.style[k] = '';
                      } else {
                        el.style[k] = String(v);
                      }
                    } catch(e) {}
                  }
                }
                console.log('[iframe CMD_SET_STYLE] Стили применены, текущий style:', el.getAttribute('style'));
                
                // Перестроим дерево после изменения стилей
                buildTree();
                
                // обновим снапшот
                try {
                  const cs = window.getComputedStyle(el);
                  post(MSG_STYLE_SNAPSHOT, {
                    id: data.id,
                    inlineStyle: el.getAttribute('style') || '',
                    computedStyle: {
                      position: cs.getPropertyValue('position'),
                      left: cs.getPropertyValue('left'),
                      top: cs.getPropertyValue('top'),
                      width: cs.getPropertyValue('width'),
                      height: cs.getPropertyValue('height'),
                      color: cs.getPropertyValue('color'),
                      backgroundColor: cs.getPropertyValue('background-color'),
                      fontSize: cs.getPropertyValue('font-size'),
                      display: cs.getPropertyValue('display'),
                    },
                  });
                } catch(e) {}
                return;
              }
              if (data.type === CMD_REQ_STYLE && data.id) {
                const el = document.querySelector(byIdSelector(String(data.id)));
                if (!el) return;
                const cs = window.getComputedStyle(el);
                post(MSG_STYLE_SNAPSHOT, {
                  id: data.id,
                  inlineStyle: el.getAttribute('style') || '',
                  computedStyle: {
                    position: cs.getPropertyValue('position'),
                    left: cs.getPropertyValue('left'),
                    top: cs.getPropertyValue('top'),
                    width: cs.getPropertyValue('width'),
                    height: cs.getPropertyValue('height'),
                    color: cs.getPropertyValue('color'),
                    backgroundColor: cs.getPropertyValue('background-color'),
                    fontSize: cs.getPropertyValue('font-size'),
                    display: cs.getPropertyValue('display'),
                  },
                });
                return;
              }
              if (data.type === CMD_SET_TEXT && data.id) {
                const el = document.querySelector(byIdSelector(String(data.id)));
                if (!el) return;
                el.innerText = data.text ?? '';
                post(MSG_TEXT_SNAPSHOT, { id: data.id, text: el.innerText || '' });
                return;
              }
              if (data.type === CMD_REQ_TEXT && data.id) {
                const el = document.querySelector(byIdSelector(String(data.id)));
                if (!el) return;
                post(MSG_TEXT_SNAPSHOT, { id: data.id, text: el.innerText || '' });
                return;
              }
              if (data.type === CMD_DELETE && data.id) {
                const el = document.querySelector(byIdSelector(String(data.id)));
                if (el) {
                  if (selected === el) clearSelected();
                  el.remove();
                  buildTree();
                }
                return;
              }
              if (data.type === CMD_INSERT && data.targetId && data.mode && data.html) {
                console.log('[iframe CMD_INSERT] Получена команда вставки', {
                  targetId: data.targetId,
                  mode: data.mode,
                  htmlPreview: String(data.html).substring(0, 100)
                });
                const target = document.querySelector(byIdSelector(String(data.targetId)));
                if (!target) {
                  console.warn('[iframe CMD_INSERT] Target не найден!', data.targetId);
                  return;
                }
                const tmp = document.createElement('div');
                tmp.innerHTML = String(data.html);
                const newEl = tmp.firstElementChild;
                if (!newEl) {
                  console.warn('[iframe CMD_INSERT] Не удалось создать элемент из HTML');
                  return;
                }
                // временный id для дерева до commit
                const newElId = ensureId(newEl);
                console.log('[iframe CMD_INSERT] ✅ Вставляю элемент с ID:', newElId);
                if (data.mode === 'child') {
                  target.appendChild(newEl);
                } else if (data.mode === 'sibling') {
                  target.insertAdjacentElement('afterend', newEl);
                }
                buildTree();
                selectEl(newEl);
                return;
              }
              if (data.type === CMD_REPARENT && data.sourceId && data.targetParentId) {
                const srcEl = document.querySelector(byIdSelector(String(data.sourceId)));
                const dstEl = document.querySelector(byIdSelector(String(data.targetParentId)));
                if (srcEl && dstEl && srcEl !== dstEl) {
                  dstEl.appendChild(srcEl);
                  buildTree();
                  selectEl(srcEl);
                }
                return;
              }
              if (data.type === CMD_SET_MOVE_MODE) {
                if (data.mode) moveMode = String(data.mode);
                if (typeof data.grid === 'number') gridStep = data.grid;
                return;
              }
            } catch(e) {}
          }, false);

          post(MSG_READY, { meta: { mode: 'edit' } });
          buildTree();
        })();
      </script>
    

      <style>
        [data-no-code-ui-id].mrpak-selected, [data-mrpak-id].mrpak-selected { outline: 2px solid #667eea !important; outline-offset: 2px; }
        .mrpak-hint { position: fixed; z-index: 9999; bottom: 10px; right: 10px; background: rgba(15,23,42,0.85); color: #fff; padding: 8px 10px; border-radius: 8px; font: 12px/1.2 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif; }
        
        /* Блокируем интерактивные элементы только в режиме редактора */
        [data-no-code-ui-id] button,
        [data-no-code-ui-id] input,
        [data-no-code-ui-id] select,
        [data-no-code-ui-id] textarea,
        [data-no-code-ui-id] a,
        [data-no-code-ui-id] [role="button"],
        [data-no-code-ui-id] [role="link"],
        [data-no-code-ui-id] [contenteditable="true"],
        [data-no-code-ui-id] [contenteditable=""],
        [data-mrpak-id] button,
        [data-mrpak-id] input,
        [data-mrpak-id] select,
        [data-mrpak-id] textarea,
        [data-mrpak-id] a,
        [data-mrpak-id] [role="button"],
        [data-mrpak-id] [role="link"],
        [data-mrpak-id] [contenteditable="true"],
        [data-mrpak-id] [contenteditable=""] {
          pointer-events: none !important;
          user-select: none !important;
          -webkit-user-select: none !important;
          -moz-user-select: none !important;
          -ms-user-select: none !important;
        }
        /* Разрешаем pointer-events только для выбора блоков */
        [data-no-code-ui-id],
        [data-mrpak-id] {
          cursor: pointer;
        }
        
      </style>
      <script>
        (function() {
          const EDIT_MODE = true;
          const ATTR_NEW = 'data-no-code-ui-id';
          const ATTR_OLD = 'data-mrpak-id';
          const SEL_ALL = '[data-no-code-ui-id],[data-mrpak-id]';
          const getId = (el) => {
            try {
              return (el && el.getAttribute && (el.getAttribute(ATTR_NEW) || el.getAttribute(ATTR_OLD))) || null;
            } catch (e) {
              return null;
            }
          };
          const ensureId = (el) => {
            try {
              if (!el || !el.getAttribute || !el.setAttribute) return null;
              const id = getId(el);
              if (id) {
                if (!el.getAttribute(ATTR_NEW)) el.setAttribute(ATTR_NEW, id);
                if (el.getAttribute(ATTR_OLD)) el.removeAttribute(ATTR_OLD);
                return id;
              }
              const tmp = 'mrpak:temp:' + Date.now() + ':' + Math.random().toString(16).slice(2, 8);
              el.setAttribute(ATTR_NEW, tmp);
              return tmp;
            } catch (e) {
              return null;
            }
          };
          const byIdSelector = (id) => {
            const safe = String(id || '').replace(/"/g,'');
            return '[data-no-code-ui-id="' + safe + '"],[data-mrpak-id="' + safe + '"]';
          };
          const MSG_SELECT = 'MRPAK_SELECT';
          const MSG_APPLY = 'MRPAK_APPLY';
          const MSG_TREE = 'MRPAK_TREE';
          const MSG_READY = 'MRPAK_READY';
          const MSG_STYLE_SNAPSHOT = 'MRPAK_STYLE_SNAPSHOT';
          const MSG_TEXT_SNAPSHOT = 'MRPAK_TEXT_SNAPSHOT';
          const MSG_DROP_TARGET = 'MRPAK_DROP_TARGET';
          const CMD_SELECT = 'MRPAK_CMD_SELECT';
          const CMD_INSERT = 'MRPAK_CMD_INSERT';
          const CMD_DELETE = 'MRPAK_CMD_DELETE';
          const CMD_SET_STYLE = 'MRPAK_CMD_SET_STYLE';
          const CMD_REQ_STYLE = 'MRPAK_CMD_REQUEST_STYLE_SNAPSHOT';
          const CMD_REPARENT = 'MRPAK_CMD_REPARENT';
          const CMD_SET_MOVE_MODE = 'MRPAK_CMD_SET_MOVE_MODE';
          const CMD_SET_TEXT = 'MRPAK_CMD_SET_TEXT';
          const CMD_REQ_TEXT = 'MRPAK_CMD_REQUEST_TEXT_SNAPSHOT';
          const CMD_START_DRAG = 'MRPAK_CMD_START_DRAG';
          const CMD_END_DRAG = 'MRPAK_CMD_END_DRAG';
          let selected = null;
          let lastSelectedId = null;
          let moveMode = 'absolute'; // absolute | relative | grid8
          let gridStep = 8;
          let dragging = null; // {sourceId}
          let dropTarget = null;

          const snap = (v) => {
            if (moveMode !== 'grid8') return v;
            const step = gridStep || 8;
            return Math.round(v / step) * step;
          };

          const getOffsetParent = (el) => el && (el.offsetParent || el.parentElement || document.body);

          const pxToNum = (s) => {
            const m = String(s || '').match(/(-?\d+(?:\.\d+)?)px/);
            return m ? Number(m[1]) : 0;
          };

          function post(type, payload) {
            try {
              window.parent && window.parent.postMessage({ type, ...payload }, '*');
            } catch (e) {}
          }

          function buildTree() {
            const nodes = {};
            const rootIds = [];
            const all = Array.from(document.querySelectorAll(SEL_ALL));
            
            // Сначала создаем все узлы
            for (const el of all) {
              const id = ensureId(el);
              if (!id) continue;
              
              // Ищем родителя более точно: идем вверх по DOM дереву и ищем ближайший элемент с id-атрибутом
              let parentEl = null;
              let current = el.parentElement;
              while (current && current !== document.body && current !== document.documentElement) {
                if (current.hasAttribute && (current.hasAttribute(ATTR_NEW) || current.hasAttribute(ATTR_OLD))) {
                  parentEl = current;
                  break;
                }
                current = current.parentElement;
              }
              
              const parentId = parentEl ? getId(parentEl) : null;
              nodes[id] = { id, tagName: el.tagName, parentId, childIds: [] };
            }
            
            // Определяем детей и корневые элементы
            for (const id of Object.keys(nodes)) {
              const p = nodes[id].parentId;
              if (p && nodes[p]) {
                nodes[p].childIds.push(id);
              } else {
                rootIds.push(id);
              }
            }
            
            // Упорядочиваем children по порядку в DOM
            for (const id of Object.keys(nodes)) {
              const el = document.querySelector(byIdSelector(id));
              if (!el) continue;
              
              const parentEl = el.parentElement;
              if (parentEl) {
                // Ищем родителя с id-атрибутом
                let parentWithId = null;
                let current = parentEl;
                while (current && current !== document.body && current !== document.documentElement) {
                  if (current.hasAttribute && (current.hasAttribute(ATTR_NEW) || current.hasAttribute(ATTR_OLD))) {
                    parentWithId = current;
                    break;
                  }
                  current = current.parentElement;
                }
                
                if (parentWithId) {
                  const pid = ensureId(parentWithId);
                  if (pid && nodes[pid]) {
                    // Получаем прямых детей с id-атрибутом в порядке DOM
                    const directChildren = Array.from(parentWithId.children)
                      .filter(child => child && child.hasAttribute && (child.hasAttribute(ATTR_NEW) || child.hasAttribute(ATTR_OLD)))
                      .map(child => ensureId(child))
                      .filter(Boolean);
                    nodes[pid].childIds = directChildren;
                  }
                }
              }
            }
            
            post(MSG_TREE, { tree: { nodes, rootIds } });
          }
          
          // Делаем buildTree доступной глобально для вызова из скрипта React
          window.__MRPAK_BUILD_TREE__ = buildTree;

          function clearSelected() {
            try {
              if (selected) selected.classList.remove('mrpak-selected');
            } catch(e) {}
            selected = null;
          }

          function selectEl(el) {
            if (!el) return;
            clearSelected();
            selected = el;
            try { selected.classList.add('mrpak-selected'); } catch(e) {}
            const id = ensureId(selected);
            lastSelectedId = id;
            const rect = selected.getBoundingClientRect();
            post(MSG_SELECT, { id, meta: { tagName: selected.tagName, rect: { x: rect.x, y: rect.y, w: rect.width, h: rect.height } } });
            buildTree();
            // отправляем снапшот inline style, чтобы UI мог показать базовые стили
            try {
              const inline = selected.getAttribute('style') || '';
              const cs = window.getComputedStyle(selected);
              const computed = {
                position: cs.getPropertyValue('position'),
                left: cs.getPropertyValue('left'),
                top: cs.getPropertyValue('top'),
                width: cs.getPropertyValue('width'),
                height: cs.getPropertyValue('height'),
                color: cs.getPropertyValue('color'),
                backgroundColor: cs.getPropertyValue('background-color'),
                fontSize: cs.getPropertyValue('font-size'),
                display: cs.getPropertyValue('display'),
                flex: cs.getPropertyValue('flex'),
                justifyContent: cs.getPropertyValue('justify-content'),
                alignItems: cs.getPropertyValue('align-items'),
                margin: cs.getPropertyValue('margin'),
                padding: cs.getPropertyValue('padding'),
              };
              post(MSG_STYLE_SNAPSHOT, { id, inlineStyle: inline, computedStyle: computed });
              const txt = selected.innerText || '';
              post(MSG_TEXT_SNAPSHOT, { id, text: txt });
            } catch(e) {}
          }

          // В режиме редактора делаем контент "неинтерактивным":
          // - гасим клики/submit/клавиатурные активации по интерактивным элементам
          // - при этом сохраняем возможность выбирать блоки кликом и двигать Shift/Alt+Drag
          function isInteractive(el) {
            if (!el || el.nodeType !== 1) return false;
            const tag = (el.tagName || '').toUpperCase();
            if (['A','BUTTON','INPUT','SELECT','TEXTAREA','LABEL','FORM','SUMMARY'].includes(tag)) return true;
            if (el.hasAttribute && el.hasAttribute('contenteditable')) return true;
            const role = el.getAttribute ? (el.getAttribute('role') || '') : '';
            if (role === 'button' || role === 'link' || role === 'checkbox' || role === 'switch') return true;
            if (typeof el.onclick === 'function') return true;
            return false;
          }

          // Hover для drop target при перетаскивании (режим reparent)
          document.addEventListener('mousemove', (ev) => {
            if (!dragging || !dragging.sourceId || dragging.mode !== 'reparent') return;
            const el = ev.target && ev.target.closest ? ev.target.closest(SEL_ALL) : null;
            const sid = dragging.sourceId;
            if (el) {
              const id = ensureId(el);
              if (id && id !== sid) {
                dropTarget = id;
                post(MSG_DROP_TARGET, { sourceId: sid, targetId: id });
              }
            } else {
              dropTarget = null;
              post(MSG_DROP_TARGET, { sourceId: sid, targetId: null });
            }
          }, true);

          // Блокируем submit форм только в режиме редактора
          if (EDIT_MODE) {
            document.addEventListener('submit', (ev) => {
              try {
                ev.preventDefault();
                ev.stopPropagation();
                ev.stopImmediatePropagation();
              } catch(e) {}
            }, true);
          }

          // Блокируем все события на интерактивных элементах только в режиме редактора
          const blockInteractiveEvents = (ev) => {
            if (!EDIT_MODE) return;
            const t = ev.target;
            if (!t) return;
            // Проверяем, является ли элемент интерактивным
            if (isInteractive(t) || (t.closest && t.closest('a,button,input,select,textarea,label,form,[role=button],[role=link],[role=checkbox],[role=switch],[contenteditable]'))) {
              try {
                ev.preventDefault();
                ev.stopPropagation();
                ev.stopImmediatePropagation();
                // Если у интерактивного элемента есть id-атрибут, выбираем его напрямую
                if (t.hasAttribute && (t.hasAttribute(ATTR_NEW) || t.hasAttribute(ATTR_OLD))) {
                  selectEl(t);
                  return;
                }
                // Иначе выбираем родительский блок
                const block = t.closest(SEL_ALL);
                if (block && block !== t) {
                  selectEl(block);
                }
              } catch(e) {}
            }
          };

          // Блокируем все события на интерактивных элементах (кроме mousedown, который обрабатывается отдельно) только в режиме редактора
          if (EDIT_MODE) {
            document.addEventListener('mouseup', blockInteractiveEvents, true);
            document.addEventListener('dblclick', blockInteractiveEvents, true);
            document.addEventListener('change', blockInteractiveEvents, true);
            document.addEventListener('input', blockInteractiveEvents, true);
            document.addEventListener('focus', blockInteractiveEvents, true);
            document.addEventListener('blur', blockInteractiveEvents, true);
            document.addEventListener('keydown', (ev) => {
              const t = ev.target;
              if (t && (isInteractive(t) || (t.closest && t.closest('a,button,input,select,textarea,[role=button],[role=link],[contenteditable]')))) {
                try {
                  ev.preventDefault();
                  ev.stopPropagation();
                  ev.stopImmediatePropagation();
                  // Если у интерактивного элемента есть id-атрибут, выбираем его напрямую
                  if (t.hasAttribute && (t.hasAttribute(ATTR_NEW) || t.hasAttribute(ATTR_OLD))) {
                    selectEl(t);
                    return;
                  }
                  // Иначе выбираем родительский блок
                  const block = t.closest(SEL_ALL);
                  if (block && block !== t) {
                    selectEl(block);
                  }
                } catch(e) {}
              }
            }, true);
            document.addEventListener('keyup', blockInteractiveEvents, true);
            document.addEventListener('keypress', blockInteractiveEvents, true);
          }
          
          // Обработка клика для выбора блоков (только в режиме редактора)
          document.addEventListener('click', (ev) => {
            if (!EDIT_MODE) return; // В preview режиме не обрабатываем клики для выбора
            
            const t = ev.target;
            // Если это интерактивный элемент, обрабатываем его
            if (t && (isInteractive(t) || (t.closest && t.closest('a,button,input,select,textarea,label,form,[role=button],[role=link],[contenteditable]')))) {
              try {
                ev.preventDefault();
                ev.stopPropagation();
                ev.stopImmediatePropagation();
                // Если у интерактивного элемента есть id-атрибут, выбираем его напрямую
                if (t.hasAttribute && (t.hasAttribute(ATTR_NEW) || t.hasAttribute(ATTR_OLD))) {
                  selectEl(t);
                  return;
                }
                // Иначе выбираем родительский блок
                const block = t.closest(SEL_ALL);
                if (block && block !== t) {
                  selectEl(block);
                  return;
                }
              } catch(e) {}
            }
            // Если это не интерактивный элемент, обрабатываем как обычный клик для выбора блока
            const el = ev.target && ev.target.closest ? ev.target.closest(SEL_ALL) : null;
            if (!el) return;
            try {
              ev.preventDefault();
              ev.stopPropagation();
            } catch(e) {}
            selectEl(el);
          }, true);

          // Shift+Drag: перенос (MVP -> position:absolute + left/top/width/height)
          // Этот обработчик также блокирует интерактивные элементы (только в режиме редактора)
          let drag = null;
          document.addEventListener('mousedown', (ev) => {
            if (!EDIT_MODE) return; // В preview режиме не обрабатываем
            
            const t = ev.target;
            // Если это интерактивный элемент, обрабатываем его
            if (t && (isInteractive(t) || (t.closest && t.closest('a,button,input,select,textarea,label,form,[role=button],[role=link],[contenteditable]')))) {
              try {
                ev.preventDefault();
                ev.stopPropagation();
                ev.stopImmediatePropagation();
                
                // Если у интерактивного элемента есть id-атрибут, используем его
                let targetEl = t;
                let targetId = null;
                if (t.hasAttribute && (t.hasAttribute(ATTR_NEW) || t.hasAttribute(ATTR_OLD))) {
                  targetId = getId(t);
                } else {
                  // Иначе ищем родительский блок
                  const block = t.closest(SEL_ALL);
                  if (block && block !== t) {
                    targetEl = block;
                    targetId = getId(block);
                  }
                }
                
                if (targetId) {
                  selectEl(targetEl);
                  // Если это Shift/Ctrl/Alt + клик, обрабатываем как drag
                  if (ev.ctrlKey || ev.metaKey) {
                    dragging = { sourceId: targetId, mode: 'reparent' };
                    post(MSG_DROP_TARGET, { sourceId: targetId, targetId: null });
                    return;
                  } else if (ev.shiftKey || ev.altKey) {
                    dragging = { sourceId: targetId, mode: ev.altKey ? 'resize' : 'move' };
                    const startRect = targetEl.getBoundingClientRect();
                    drag = {
                      mode: ev.altKey ? 'resize' : 'move',
                      sx: ev.clientX,
                      sy: ev.clientY,
                      rect: startRect,
                    };
                    return;
                  }
                }
                return;
              } catch(e) {}
            }
            
            const el = ev.target && ev.target.closest ? ev.target.closest(SEL_ALL) : null;
            if (!el) return;
            
            // Ctrl/Cmd + drag => reparent drag
            if (ev.ctrlKey || ev.metaKey) {
              ev.preventDefault();
              ev.stopPropagation();
              const id = ensureId(el);
              dragging = { sourceId: id, mode: 'reparent' };
              selectEl(el);
              post(MSG_DROP_TARGET, { sourceId: id, targetId: null });
              return;
            }
            if (!selected) return;
            if (!ev.shiftKey && !ev.altKey) return;
            ev.preventDefault();
            ev.stopPropagation();
            const id = ensureId(selected);
            dragging = { sourceId: id, mode: ev.altKey ? 'resize' : 'move' };
            const startRect = selected.getBoundingClientRect();
            drag = {
              mode: ev.altKey ? 'resize' : 'move',
              sx: ev.clientX,
              sy: ev.clientY,
              rect: startRect,
            };
          }, true);

          document.addEventListener('mousemove', (ev) => {
            if (!drag || !selected) return;
            const dx = ev.clientX - drag.sx;
            const dy = ev.clientY - drag.sy;
            const id = ensureId(selected);
            
            if (drag.mode === 'move') {
              selected.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
              
              // Отправляем промежуточные изменения при каждом движении
              const parent = getOffsetParent(selected);
              const parentRect = parent && parent.getBoundingClientRect ? parent.getBoundingClientRect() : { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight };
              const ps = parent ? window.getComputedStyle(parent) : null;
              const padLeft = ps ? parseFloat(ps.getPropertyValue('padding-left')) || 0 : 0;
              const padTop = ps ? parseFloat(ps.getPropertyValue('padding-top')) || 0 : 0;
              const padRight = ps ? parseFloat(ps.getPropertyValue('padding-right')) || 0 : 0;
              const padBottom = ps ? parseFloat(ps.getPropertyValue('padding-bottom')) || 0 : 0;
              
              if (moveMode === 'relative') {
                const cs = window.getComputedStyle(selected);
                const baseLeft = cs.left === 'auto' ? 0 : pxToNum(cs.left);
                const baseTop = cs.top === 'auto' ? 0 : pxToNum(cs.top);
                const left = snap(baseLeft + dx);
                const top = snap(baseTop + dy);
                
                if ('react' === 'html') {
                  post(MSG_APPLY, { id, patch: { position: 'relative', left: left + 'px', top: top + 'px' }, isIntermediate: true });
                } else {
                  post(MSG_APPLY, { id, patch: { position: 'relative', left: left, top: top }, isIntermediate: true });
                }
              } else {
                const startLeft = drag.rect.left - parentRect.left - padLeft;
                const startTop = drag.rect.top - parentRect.top - padTop;
                
                let left = snap(startLeft + dx);
                let top = snap(startTop + dy);
                
                const maxLeft = parentRect.width - padRight - snap(drag.rect.width);
                const maxTop = parentRect.height - padBottom - snap(drag.rect.height);
                const minLeft = padLeft;
                const minTop = padTop;
                left = Math.min(Math.max(left, minLeft), maxLeft);
                top = Math.min(Math.max(top, minTop), maxTop);
                
                if ('react' === 'html') {
                  post(MSG_APPLY, { id, patch: { position: 'absolute', left: left + 'px', top: top + 'px' }, isIntermediate: true });
                } else {
                  post(MSG_APPLY, { id, patch: { position: 'absolute', left: left, top: top }, isIntermediate: true });
                }
              }
            } else {
              const w = snap(Math.max(1, drag.rect.width + dx));
              const h = snap(Math.max(1, drag.rect.height + dy));
              selected.style.width = w + 'px';
              selected.style.height = h + 'px';
              
              // Отправляем промежуточные изменения при каждом движении
              if ('react' === 'html') {
                post(MSG_APPLY, { id, patch: { width: w + 'px', height: h + 'px' }, isIntermediate: true });
              } else {
                post(MSG_APPLY, { id, patch: { width: w, height: h }, isIntermediate: true });
              }
            }
          }, true);

          // Touch события для мобильных устройств
          document.addEventListener('touchmove', (ev) => {
            if (!drag || !selected) return;
            const touch = ev.touches[0];
            if (!touch) return;
            const dx = touch.clientX - drag.sx;
            const dy = touch.clientY - drag.sy;
            const id = ensureId(selected);
            
            if (drag.mode === 'move') {
              selected.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
              
              // Отправляем промежуточные изменения при каждом движении
              const parent = getOffsetParent(selected);
              const parentRect = parent && parent.getBoundingClientRect ? parent.getBoundingClientRect() : { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight };
              const ps = parent ? window.getComputedStyle(parent) : null;
              const padLeft = ps ? parseFloat(ps.getPropertyValue('padding-left')) || 0 : 0;
              const padTop = ps ? parseFloat(ps.getPropertyValue('padding-top')) || 0 : 0;
              const padRight = ps ? parseFloat(ps.getPropertyValue('padding-right')) || 0 : 0;
              const padBottom = ps ? parseFloat(ps.getPropertyValue('padding-bottom')) || 0 : 0;
              
              if (moveMode === 'relative') {
                const cs = window.getComputedStyle(selected);
                const baseLeft = cs.left === 'auto' ? 0 : pxToNum(cs.left);
                const baseTop = cs.top === 'auto' ? 0 : pxToNum(cs.top);
                const left = snap(baseLeft + dx);
                const top = snap(baseTop + dy);
                
                if ('react' === 'html') {
                  post(MSG_APPLY, { id, patch: { position: 'relative', left: left + 'px', top: top + 'px' }, isIntermediate: true });
                } else {
                  post(MSG_APPLY, { id, patch: { position: 'relative', left: left, top: top }, isIntermediate: true });
                }
              } else {
                const startLeft = drag.rect.left - parentRect.left - padLeft;
                const startTop = drag.rect.top - parentRect.top - padTop;
                
                let left = snap(startLeft + dx);
                let top = snap(startTop + dy);
                
                const maxLeft = parentRect.width - padRight - snap(drag.rect.width);
                const maxTop = parentRect.height - padBottom - snap(drag.rect.height);
                const minLeft = padLeft;
                const minTop = padTop;
                left = Math.min(Math.max(left, minLeft), maxLeft);
                top = Math.min(Math.max(top, minTop), maxTop);
                
                if ('react' === 'html') {
                  post(MSG_APPLY, { id, patch: { position: 'absolute', left: left + 'px', top: top + 'px' }, isIntermediate: true });
                } else {
                  post(MSG_APPLY, { id, patch: { position: 'absolute', left: left, top: top }, isIntermediate: true });
                }
              }
            } else {
              const w = snap(Math.max(1, drag.rect.width + dx));
              const h = snap(Math.max(1, drag.rect.height + dy));
              selected.style.width = w + 'px';
              selected.style.height = h + 'px';
              
              // Отправляем промежуточные изменения при каждом движении
              if ('react' === 'html') {
                post(MSG_APPLY, { id, patch: { width: w + 'px', height: h + 'px' }, isIntermediate: true });
              } else {
                post(MSG_APPLY, { id, patch: { width: w, height: h }, isIntermediate: true });
              }
            }
          }, { passive: false });

          document.addEventListener('mouseup', (ev) => {
            // reparent drag (Ctrl/Cmd + drag)
            if (dragging && dragging.mode === 'reparent') {
              if (dropTarget && dragging.sourceId && dropTarget !== dragging.sourceId) {
                post(MSG_APPLY, { id: dragging.sourceId, patch: { __reparentTo: dropTarget } });
              }
              dragging = null;
              dropTarget = null;
              drag = null;
              return;
            }

            if (!drag || !selected) return;
            const dx = ev.clientX - drag.sx;
            const dy = ev.clientY - drag.sy;
            const id = ensureId(selected);

            // координаты родителя и padding для ограничения
            const parent = getOffsetParent(selected);
            const parentRect = parent && parent.getBoundingClientRect ? parent.getBoundingClientRect() : { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight };
            const ps = parent ? window.getComputedStyle(parent) : null;
            const padLeft = ps ? parseFloat(ps.getPropertyValue('padding-left')) || 0 : 0;
            const padTop = ps ? parseFloat(ps.getPropertyValue('padding-top')) || 0 : 0;
            const padRight = ps ? parseFloat(ps.getPropertyValue('padding-right')) || 0 : 0;
            const padBottom = ps ? parseFloat(ps.getPropertyValue('padding-bottom')) || 0 : 0;
            const scrollLeft = parent ? (parent.scrollLeft || 0) : 0;
            const scrollTop = parent ? (parent.scrollTop || 0) : 0;

            if (drag.mode === 'move') {
              selected.style.transform = '';

              if (moveMode === 'relative') {
                const cs = window.getComputedStyle(selected);
                const baseLeft = cs.left === 'auto' ? 0 : pxToNum(cs.left);
                const baseTop = cs.top === 'auto' ? 0 : pxToNum(cs.top);
                const left = snap(baseLeft + dx);
                const top = snap(baseTop + dy);
                selected.style.position = 'relative';
                selected.style.left = left + 'px';
                selected.style.top = top + 'px';

                if ('react' === 'html') {
                  post(MSG_APPLY, { id, patch: { position: 'relative', left: left + 'px', top: top + 'px' }, isIntermediate: false });
                } else {
                  post(MSG_APPLY, { id, patch: { position: 'relative', left: left, top: top }, isIntermediate: false });
                }
              } else {
                // absolute с ограничением по padding-box
                const startLeft = drag.rect.left - parentRect.left - padLeft;
                const startTop = drag.rect.top - parentRect.top - padTop;
                
                let left = snap(startLeft + dx);
                let top = snap(startTop + dy);

                // Ограничиваем позицию padding-box родителя
                const maxLeft = parentRect.width - padRight - snap(drag.rect.width);
                const maxTop = parentRect.height - padBottom - snap(drag.rect.height);
                const minLeft = padLeft;
                const minTop = padTop;
                left = Math.min(Math.max(left, minLeft), maxLeft);
                top = Math.min(Math.max(top, minTop), maxTop);

                selected.style.position = 'absolute';
                selected.style.left = left + 'px';
                selected.style.top = top + 'px';

                if ('react' === 'html') {
                  post(MSG_APPLY, { id, patch: { position: 'absolute', left: left + 'px', top: top + 'px' }, isIntermediate: false });
                } else {
                  post(MSG_APPLY, { id, patch: { position: 'absolute', left: left, top: top }, isIntermediate: false });
                }
              }
            } else {
              const w = snap(Math.max(1, drag.rect.width + dx));
              const h = snap(Math.max(1, drag.rect.height + dy));
              // constrain size чтобы не выходить за padding-box справа/снизу
              const maxW = parentRect.width - padLeft - padRight;
              const maxH = parentRect.height - padTop - padBottom;
              const cw = Math.min(w, maxW);
              const ch = Math.min(h, maxH);

              selected.style.width = cw + 'px';
              selected.style.height = ch + 'px';
              if ('react' === 'html') {
                post(MSG_APPLY, { id, patch: { width: cw + 'px', height: ch + 'px' }, isIntermediate: false });
              } else {
                post(MSG_APPLY, { id, patch: { width: cw, height: ch }, isIntermediate: false });
              }
            }

            drag = null;
            dragging = null;
            dropTarget = null;
          }, true);

          // Подсказка
          try {
            const hint = document.createElement('div');
            hint.className = 'mrpak-hint';
            hint.textContent = 'MRPAK Editor: клик = выбрать, Shift+Drag = переместить, Alt+Drag = изменить размер';
            document.body.appendChild(hint);
          } catch(e) {}

          // Команды из UI (локальные изменения)
          window.addEventListener('message', (event) => {
            const data = event && event.data;
            if (!data || typeof data !== 'object') return;
            try {
              if (data.type === CMD_SELECT && data.id) {
                const el = document.querySelector(byIdSelector(String(data.id)));
                if (el) selectEl(el);
                return;
              }
              if (data.type === CMD_SET_STYLE && data.id) {
                console.log('[iframe CMD_SET_STYLE] Получена команда:', {
                  id: data.id,
                  patch: data.patch,
                  hasPatch: !!data.patch
                });
                const el = document.querySelector(byIdSelector(String(data.id)));
                if (!el) {
                  console.warn('[iframe CMD_SET_STYLE] Элемент не найден:', data.id);
                  return;
                }
                const patch = data.patch || {};
                console.log('[iframe CMD_SET_STYLE] Применяю патч:', patch);
                for (const k in patch) {
                  const v = patch[k];
                  if (k.includes('-')) {
                    if (v === null || v === undefined || v === '') {
                      // Удаляем свойство, если значение пустое
                      el.style.removeProperty(k);
                    } else {
                      el.style.setProperty(k, String(v));
                    }
                  } else {
                    // DOM style: camelCase
                    try { 
                      if (v === null || v === undefined || v === '') {
                        el.style[k] = '';
                      } else {
                        el.style[k] = String(v);
                      }
                    } catch(e) {}
                  }
                }
                console.log('[iframe CMD_SET_STYLE] Стили применены, текущий style:', el.getAttribute('style'));
                
                // Перестроим дерево после изменения стилей
                buildTree();
                
                // обновим снапшот
                try {
                  const cs = window.getComputedStyle(el);
                  post(MSG_STYLE_SNAPSHOT, {
                    id: data.id,
                    inlineStyle: el.getAttribute('style') || '',
                    computedStyle: {
                      position: cs.getPropertyValue('position'),
                      left: cs.getPropertyValue('left'),
                      top: cs.getPropertyValue('top'),
                      width: cs.getPropertyValue('width'),
                      height: cs.getPropertyValue('height'),
                      color: cs.getPropertyValue('color'),
                      backgroundColor: cs.getPropertyValue('background-color'),
                      fontSize: cs.getPropertyValue('font-size'),
                      display: cs.getPropertyValue('display'),
                    },
                  });
                } catch(e) {}
                return;
              }
              if (data.type === CMD_REQ_STYLE && data.id) {
                const el = document.querySelector(byIdSelector(String(data.id)));
                if (!el) return;
                const cs = window.getComputedStyle(el);
                post(MSG_STYLE_SNAPSHOT, {
                  id: data.id,
                  inlineStyle: el.getAttribute('style') || '',
                  computedStyle: {
                    position: cs.getPropertyValue('position'),
                    left: cs.getPropertyValue('left'),
                    top: cs.getPropertyValue('top'),
                    width: cs.getPropertyValue('width'),
                    height: cs.getPropertyValue('height'),
                    color: cs.getPropertyValue('color'),
                    backgroundColor: cs.getPropertyValue('background-color'),
                    fontSize: cs.getPropertyValue('font-size'),
                    display: cs.getPropertyValue('display'),
                  },
                });
                return;
              }
              if (data.type === CMD_SET_TEXT && data.id) {
                const el = document.querySelector(byIdSelector(String(data.id)));
                if (!el) return;
                el.innerText = data.text ?? '';
                post(MSG_TEXT_SNAPSHOT, { id: data.id, text: el.innerText || '' });
                return;
              }
              if (data.type === CMD_REQ_TEXT && data.id) {
                const el = document.querySelector(byIdSelector(String(data.id)));
                if (!el) return;
                post(MSG_TEXT_SNAPSHOT, { id: data.id, text: el.innerText || '' });
                return;
              }
              if (data.type === CMD_DELETE && data.id) {
                const el = document.querySelector(byIdSelector(String(data.id)));
                if (el) {
                  if (selected === el) clearSelected();
                  el.remove();
                  buildTree();
                }
                return;
              }
              if (data.type === CMD_INSERT && data.targetId && data.mode && data.html) {
                console.log('[iframe CMD_INSERT] Получена команда вставки', {
                  targetId: data.targetId,
                  mode: data.mode,
                  htmlPreview: String(data.html).substring(0, 100)
                });
                const target = document.querySelector(byIdSelector(String(data.targetId)));
                if (!target) {
                  console.warn('[iframe CMD_INSERT] Target не найден!', data.targetId);
                  return;
                }
                const tmp = document.createElement('div');
                tmp.innerHTML = String(data.html);
                const newEl = tmp.firstElementChild;
                if (!newEl) {
                  console.warn('[iframe CMD_INSERT] Не удалось создать элемент из HTML');
                  return;
                }
                // временный id для дерева до commit
                const newElId = ensureId(newEl);
                console.log('[iframe CMD_INSERT] ✅ Вставляю элемент с ID:', newElId);
                if (data.mode === 'child') {
                  target.appendChild(newEl);
                } else if (data.mode === 'sibling') {
                  target.insertAdjacentElement('afterend', newEl);
                }
                buildTree();
                selectEl(newEl);
                return;
              }
              if (data.type === CMD_REPARENT && data.sourceId && data.targetParentId) {
                const srcEl = document.querySelector(byIdSelector(String(data.sourceId)));
                const dstEl = document.querySelector(byIdSelector(String(data.targetParentId)));
                if (srcEl && dstEl && srcEl !== dstEl) {
                  dstEl.appendChild(srcEl);
                  buildTree();
                  selectEl(srcEl);
                }
                return;
              }
              if (data.type === CMD_SET_MOVE_MODE) {
                if (data.mode) moveMode = String(data.mode);
                if (typeof data.grid === 'number') gridStep = data.grid;
                return;
              }
            } catch(e) {}
          }, false);

          post(MSG_READY, { meta: { mode: 'edit' } });
          buildTree();
        })();
      </script>
    
</body>
</html>
    :74
(anonymous) @ VM3732 html;charset=utf-8,
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Component Preview</title>
    <script>
        window.__MRPAK_FILE_PATH__ = "/Users/deu/Projects/no-code-ui/tests/2-simple-react/App.jsx";
    </script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Ждем полной загрузки React перед инициализацией -->
    <script>
      // Функция для безопасной инициализации после загрузки React
      function initializeReactGlobals() {
        if (typeof React === 'undefined' || !React) {
          console.warn('[Init] React not loaded yet, retrying...');
          setTimeout(initializeReactGlobals, 50);
          return;
        }
        
        console.log('[Init] React loaded, initializing globals...');
        console.log('[React Hooks] Making all React hooks and APIs globally available...');
        
        // ========================================
        // БАЗОВЫЕ ХУКИ (React 16.8+)
        // ========================================
        if (React.useState) window.useState = React.useState;
          if (React.useEffect) window.useEffect = React.useEffect;
          if (React.useContext) window.useContext = React.useContext;
          
          // ========================================
          // ДОПОЛНИТЕЛЬНЫЕ ХУКИ
          // ========================================
          if (React.useReducer) window.useReducer = React.useReducer;
          if (React.useCallback) window.useCallback = React.useCallback;
          if (React.useMemo) window.useMemo = React.useMemo;
          if (React.useRef) window.useRef = React.useRef;
          if (React.useImperativeHandle) window.useImperativeHandle = React.useImperativeHandle;
          if (React.useLayoutEffect) window.useLayoutEffect = React.useLayoutEffect;
          if (React.useDebugValue) window.useDebugValue = React.useDebugValue;
          
          // ========================================
          // REACT 18+ ХУКИ
          // ========================================
          if (React.useId) window.useId = React.useId;
          if (React.useTransition) window.useTransition = React.useTransition;
          if (React.useDeferredValue) window.useDeferredValue = React.useDeferredValue;
          if (React.useSyncExternalStore) window.useSyncExternalStore = React.useSyncExternalStore;
          if (React.useInsertionEffect) window.useInsertionEffect = React.useInsertionEffect;
          
          // ========================================
          // ЭКСПЕРИМЕНТАЛЬНЫЕ ХУКИ (React 19+, если доступны)
          // ========================================
          if (React.use) window.use = React.use;
          if (React.useOptimistic) window.useOptimistic = React.useOptimistic;
          if (React.useFormStatus) window.useFormStatus = React.useFormStatus;
          if (React.useFormState) window.useFormState = React.useFormState;
          if (React.useActionState) window.useActionState = React.useActionState;
          
          // ========================================
          // REACT API - КОМПОНЕНТЫ И УТИЛИТЫ
          // ========================================
          if (React.createContext) window.createContext = React.createContext;
          if (React.forwardRef) window.forwardRef = React.forwardRef;
          if (React.memo) window.memo = React.memo;
          if (React.lazy) window.lazy = React.lazy;
          if (React.Suspense) window.Suspense = React.Suspense;
          if (React.Fragment) window.Fragment = React.Fragment;
          if (React.StrictMode) window.StrictMode = React.StrictMode;
          if (React.Profiler) window.Profiler = React.Profiler;
          
          // ========================================
          // КЛАССОВЫЕ КОМПОНЕНТЫ
          // ========================================
          if (React.Component) window.Component = React.Component;
          if (React.PureComponent) window.PureComponent = React.PureComponent;
          
          // ========================================
          // СОЗДАНИЕ ЭЛЕМЕНТОВ
          // ========================================
          if (React.createElement) window.createElement = React.createElement;
          if (React.cloneElement) window.cloneElement = React.cloneElement;
          if (React.createFactory) window.createFactory = React.createFactory;
          if (React.isValidElement) window.isValidElement = React.isValidElement;
          
          // ========================================
          // CHILDREN УТИЛИТЫ
          // ========================================
          if (React.Children) {
            window.Children = React.Children;
          }
          
          // ========================================
          // REACT 18+ CONCURRENT FEATURES
          // ========================================
          if (React.startTransition) window.startTransition = React.startTransition;
          
          // Подсчет доступных хуков
          const hooks = [
            'useState', 'useEffect', 'useContext', 'useReducer', 'useCallback',
            'useMemo', 'useRef', 'useImperativeHandle', 'useLayoutEffect', 'useDebugValue',
            'useId', 'useTransition', 'useDeferredValue', 'useSyncExternalStore', 'useInsertionEffect',
            'use', 'useOptimistic', 'useFormStatus', 'useFormState', 'useActionState'
          ].filter(hook => React[hook]);
        
        console.log('[React Hooks] Total hooks available:', hooks.length);
        console.log('[React Hooks] Available hooks:', hooks.join(', '));
        console.log('[Init] React globals initialized successfully');
      }
      
      // Запускаем инициализацию
      initializeReactGlobals();
    </script>
    
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: #f5f5f5;
        }
        #root {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .error {
            color: red;
            padding: 20px;
            background: #fee;
            border-radius: 4px;
            margin: 20px 0;
        }
        .info {
            color: #666;
            padding: 10px;
            background: #e3f2fd;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="info">
        <strong>React Component Preview</strong><br>
        Компонент загружается из выбранного файла...
    </div>
    <div id="root"></div>
    <script type="text/babel" data-type="module">
        // Делаем все React хуки доступными в Babel скрипте
        const React = window.React;
        
        // Базовые хуки (React 16.8+)
        const { 
          useState, useEffect, useContext, useReducer, useCallback, useMemo, useRef,
          useImperativeHandle, useLayoutEffect, useDebugValue
        } = React;
        
        // React 18+ хуки (безопасная деструктуризация)
        const useId = React.useId || (() => Math.random().toString(36));
        const useTransition = React.useTransition || (() => [false, (fn) => fn()]);
        const useDeferredValue = React.useDeferredValue || ((value) => value);
        const useSyncExternalStore = React.useSyncExternalStore;
        const useInsertionEffect = React.useInsertionEffect || useLayoutEffect;
        
        // React 19+ экспериментальные хуки (если доступны)
        const use = React.use;
        const useOptimistic = React.useOptimistic;
        const useFormStatus = React.useFormStatus;
        const useFormState = React.useFormState;
        const useActionState = React.useActionState;
        
        // React API
        const { 
          createContext, forwardRef, memo, lazy, Suspense, Fragment,
          Component, PureComponent, createElement, cloneElement, isValidElement,
          Children, StrictMode, Profiler, startTransition
        } = React;
        
        window.__modules__ = window.__modules__ || {};
        console.log('Before loading modules, window.__modules__ initialized');
        
        
        // Предварительная регистрация всех модулей (создаем пустые слоты)
        
        
        console.log('Pre-registered 0 module paths:', []);
        
        // Теперь загружаем модули (они заполнят предварительно зарегистрированные слоты)
        
        
        console.log('All modules loaded. Total modules:', Object.keys(window.__modules__ || {}).length);
        console.log('Registered module keys:', Object.keys(window.__modules__ || {}));
    
        
        console.log('Available modules:', Object.keys(window.__modules__ || {}));
        
        try {
            /**
 * Простой однофайловый React компонент для тестирования ReactFramework
 */
function App() {
  const [count, setCount] = useState(0);
  const [message, setMessage] = useState('');

  const handleClick = () => {
    setCount(count + 1);
    setMessage(`Кнопка нажата ${count + 1} раз`);

  };

  return (
    <div style={{
      fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
      background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
      minHeight: '100vh',
      padding: '20px',
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center'
    }} data-no-code-ui-id="mrpak:App.jsx:369:671:div">
      <div style={{
        maxWidth: '600px',
        background: 'white',
        borderRadius: '12px',
        padding: '32px',
        boxShadow: '0 10px 40px rgba(0,0,0,0.2)'
      }} data-no-code-ui-id="mrpak:App.jsx:678:861:div">
        

        <div style={{
          background: '#f8f9fa',
          borderRadius: '8px',
          padding: '20px',
          margin: '16px 0',
          border: '2px solid #e9ecef'
        }} data-no-code-ui-id="mrpak:App.jsx:880:1062:div">
          <h2 style={{ color: '#764ba2', marginTop: 0, position: "relative", left: 3.5, top: -61.922 }} data-no-code-ui-id="mrpak:App.jsx:1073:1167:h2">Счетчик</h2>
          <p style={{ color: '#495057', fontSize: '18px', position: "relative", left: 25, top: -2.0780000000000003, width: 125, height: 80 }} data-no-code-ui-id="mrpak:App.jsx:1190:1322:p">
            Текущее значение: <strong data-no-code-ui-id="mrpak:App.jsx:1353:1361:strong">{count}</strong>
          </p>
          <button
            onClick={handleClick}
            style={{
              background: '#667eea',
              color: 'white',
              border: 'none',
              padding: '12px 24px',
              borderRadius: '6px',
              fontSize: '16px',
              cursor: 'pointer',
              transition: 'all 0.3s'
            }} data-no-code-ui-id="mrpak:App.jsx:1403:1751:button">

            Увеличить счетчик
          </button>
          {message &&
          <p style={{
            marginTop: '16px',
            color: '#28a745',
            fontWeight: '600'
          }} data-no-code-ui-id="mrpak:App.jsx:1835:1951:p">
              {message}
            </p>
          }
        </div>

        <div style={{
          background: '#f8f9fa',
          borderRadius: '8px',
          padding: '20px',
          margin: '16px 0',
          border: '2px solid #e9ecef'
        }} data-no-code-ui-id="mrpak:App.jsx:2029:2211:div">
          <h3 style={{ color: '#495057', marginTop: 0 }} data-no-code-ui-id="mrpak:App.jsx:2222:2269:h3">О тесте</h3>
          <p style={{ color: '#6c757d', lineHeight: '1.6' }} data-no-code-ui-id="mrpak:App.jsx:2292:2343:p">
            Этот компонент тестирует ReactFramework: инструментацию JSX,
            обработку зависимостей, применение стилей и операции с элементами.
          </p>
        </div>
      </div>
    </div>);

}
            
            let Component = null;
            if (typeof App !== 'undefined') {
                Component = App;
              }
            
            if (Component) {
                const root = ReactDOM.createRoot(document.getElementById('root'));
                root.render(React.createElement(Component));
                
                setTimeout(() => {
                  const rootElement = document.getElementById('root');
                  const filePath = window.__MRPAK_FILE_PATH__ || '';
                  
                  if (window.__MRPAK_BUILD_TREE__ && typeof window.__MRPAK_BUILD_TREE__ === 'function') {
                    window.__MRPAK_BUILD_TREE__();
                  }
                  
                  const observer = new MutationObserver((mutations) => {
                    const rootElement = document.getElementById('root');
                    if (rootElement) {
                      if (typeof buildTree === 'function') {
                        buildTree();
                      }
                    }
                  });
                  
                  observer.observe(document.body, {
                    childList: true,
                    subtree: true
                  });
                }, 100);
            } else {
                const foundComponents = ["function"];
                const errorMsg = foundComponents.length > 0 
                  ? 'Найдены компоненты: ' + foundComponents.join(', ') + '. Но не удалось их использовать для рендеринга.'
                  : 'Не найден компонент для рендеринга.';
                document.getElementById('root').innerHTML = '<div class="error">' + errorMsg + '</div>';
            }
        } catch (error) {
            document.getElementById('root').innerHTML = '<div class="error"><strong>Ошибка выполнения:</strong><br>' + error.message + '</div>';
            console.error('React execution error:', error);
        }
    </script>

      <style>
        [data-no-code-ui-id].mrpak-selected, [data-mrpak-id].mrpak-selected { outline: 2px solid #667eea !important; outline-offset: 2px; }
        .mrpak-hint { position: fixed; z-index: 9999; bottom: 10px; right: 10px; background: rgba(15,23,42,0.85); color: #fff; padding: 8px 10px; border-radius: 8px; font: 12px/1.2 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif; }
        
      </style>
      <script>
        (function() {
          const EDIT_MODE = false;
          const ATTR_NEW = 'data-no-code-ui-id';
          const ATTR_OLD = 'data-mrpak-id';
          const SEL_ALL = '[data-no-code-ui-id],[data-mrpak-id]';
          const getId = (el) => {
            try {
              return (el && el.getAttribute && (el.getAttribute(ATTR_NEW) || el.getAttribute(ATTR_OLD))) || null;
            } catch (e) {
              return null;
            }
          };
          const ensureId = (el) => {
            try {
              if (!el || !el.getAttribute || !el.setAttribute) return null;
              const id = getId(el);
              if (id) {
                if (!el.getAttribute(ATTR_NEW)) el.setAttribute(ATTR_NEW, id);
                if (el.getAttribute(ATTR_OLD)) el.removeAttribute(ATTR_OLD);
                return id;
              }
              const tmp = 'mrpak:temp:' + Date.now() + ':' + Math.random().toString(16).slice(2, 8);
              el.setAttribute(ATTR_NEW, tmp);
              return tmp;
            } catch (e) {
              return null;
            }
          };
          const byIdSelector = (id) => {
            const safe = String(id || '').replace(/"/g,'');
            return '[data-no-code-ui-id="' + safe + '"],[data-mrpak-id="' + safe + '"]';
          };
          const MSG_SELECT = 'MRPAK_SELECT';
          const MSG_APPLY = 'MRPAK_APPLY';
          const MSG_TREE = 'MRPAK_TREE';
          const MSG_READY = 'MRPAK_READY';
          const MSG_STYLE_SNAPSHOT = 'MRPAK_STYLE_SNAPSHOT';
          const MSG_TEXT_SNAPSHOT = 'MRPAK_TEXT_SNAPSHOT';
          const MSG_DROP_TARGET = 'MRPAK_DROP_TARGET';
          const CMD_SELECT = 'MRPAK_CMD_SELECT';
          const CMD_INSERT = 'MRPAK_CMD_INSERT';
          const CMD_DELETE = 'MRPAK_CMD_DELETE';
          const CMD_SET_STYLE = 'MRPAK_CMD_SET_STYLE';
          const CMD_REQ_STYLE = 'MRPAK_CMD_REQUEST_STYLE_SNAPSHOT';
          const CMD_REPARENT = 'MRPAK_CMD_REPARENT';
          const CMD_SET_MOVE_MODE = 'MRPAK_CMD_SET_MOVE_MODE';
          const CMD_SET_TEXT = 'MRPAK_CMD_SET_TEXT';
          const CMD_REQ_TEXT = 'MRPAK_CMD_REQUEST_TEXT_SNAPSHOT';
          const CMD_START_DRAG = 'MRPAK_CMD_START_DRAG';
          const CMD_END_DRAG = 'MRPAK_CMD_END_DRAG';
          let selected = null;
          let lastSelectedId = null;
          let moveMode = 'absolute'; // absolute | relative | grid8
          let gridStep = 8;
          let dragging = null; // {sourceId}
          let dropTarget = null;

          const snap = (v) => {
            if (moveMode !== 'grid8') return v;
            const step = gridStep || 8;
            return Math.round(v / step) * step;
          };

          const getOffsetParent = (el) => el && (el.offsetParent || el.parentElement || document.body);

          const pxToNum = (s) => {
            const m = String(s || '').match(/(-?\d+(?:\.\d+)?)px/);
            return m ? Number(m[1]) : 0;
          };

          function post(type, payload) {
            try {
              window.parent && window.parent.postMessage({ type, ...payload }, '*');
            } catch (e) {}
          }

          function buildTree() {
            const nodes = {};
            const rootIds = [];
            const all = Array.from(document.querySelectorAll(SEL_ALL));
            
            // Сначала создаем все узлы
            for (const el of all) {
              const id = ensureId(el);
              if (!id) continue;
              
              // Ищем родителя более точно: идем вверх по DOM дереву и ищем ближайший элемент с id-атрибутом
              let parentEl = null;
              let current = el.parentElement;
              while (current && current !== document.body && current !== document.documentElement) {
                if (current.hasAttribute && (current.hasAttribute(ATTR_NEW) || current.hasAttribute(ATTR_OLD))) {
                  parentEl = current;
                  break;
                }
                current = current.parentElement;
              }
              
              const parentId = parentEl ? getId(parentEl) : null;
              nodes[id] = { id, tagName: el.tagName, parentId, childIds: [] };
            }
            
            // Определяем детей и корневые элементы
            for (const id of Object.keys(nodes)) {
              const p = nodes[id].parentId;
              if (p && nodes[p]) {
                nodes[p].childIds.push(id);
              } else {
                rootIds.push(id);
              }
            }
            
            // Упорядочиваем children по порядку в DOM
            for (const id of Object.keys(nodes)) {
              const el = document.querySelector(byIdSelector(id));
              if (!el) continue;
              
              const parentEl = el.parentElement;
              if (parentEl) {
                // Ищем родителя с id-атрибутом
                let parentWithId = null;
                let current = parentEl;
                while (current && current !== document.body && current !== document.documentElement) {
                  if (current.hasAttribute && (current.hasAttribute(ATTR_NEW) || current.hasAttribute(ATTR_OLD))) {
                    parentWithId = current;
                    break;
                  }
                  current = current.parentElement;
                }
                
                if (parentWithId) {
                  const pid = ensureId(parentWithId);
                  if (pid && nodes[pid]) {
                    // Получаем прямых детей с id-атрибутом в порядке DOM
                    const directChildren = Array.from(parentWithId.children)
                      .filter(child => child && child.hasAttribute && (child.hasAttribute(ATTR_NEW) || child.hasAttribute(ATTR_OLD)))
                      .map(child => ensureId(child))
                      .filter(Boolean);
                    nodes[pid].childIds = directChildren;
                  }
                }
              }
            }
            
            post(MSG_TREE, { tree: { nodes, rootIds } });
          }
          
          // Делаем buildTree доступной глобально для вызова из скрипта React
          window.__MRPAK_BUILD_TREE__ = buildTree;

          function clearSelected() {
            try {
              if (selected) selected.classList.remove('mrpak-selected');
            } catch(e) {}
            selected = null;
          }

          function selectEl(el) {
            if (!el) return;
            clearSelected();
            selected = el;
            try { selected.classList.add('mrpak-selected'); } catch(e) {}
            const id = ensureId(selected);
            lastSelectedId = id;
            const rect = selected.getBoundingClientRect();
            post(MSG_SELECT, { id, meta: { tagName: selected.tagName, rect: { x: rect.x, y: rect.y, w: rect.width, h: rect.height } } });
            buildTree();
            // отправляем снапшот inline style, чтобы UI мог показать базовые стили
            try {
              const inline = selected.getAttribute('style') || '';
              const cs = window.getComputedStyle(selected);
              const computed = {
                position: cs.getPropertyValue('position'),
                left: cs.getPropertyValue('left'),
                top: cs.getPropertyValue('top'),
                width: cs.getPropertyValue('width'),
                height: cs.getPropertyValue('height'),
                color: cs.getPropertyValue('color'),
                backgroundColor: cs.getPropertyValue('background-color'),
                fontSize: cs.getPropertyValue('font-size'),
                display: cs.getPropertyValue('display'),
                flex: cs.getPropertyValue('flex'),
                justifyContent: cs.getPropertyValue('justify-content'),
                alignItems: cs.getPropertyValue('align-items'),
                margin: cs.getPropertyValue('margin'),
                padding: cs.getPropertyValue('padding'),
              };
              post(MSG_STYLE_SNAPSHOT, { id, inlineStyle: inline, computedStyle: computed });
              const txt = selected.innerText || '';
              post(MSG_TEXT_SNAPSHOT, { id, text: txt });
            } catch(e) {}
          }

          // В режиме редактора делаем контент "неинтерактивным":
          // - гасим клики/submit/клавиатурные активации по интерактивным элементам
          // - при этом сохраняем возможность выбирать блоки кликом и двигать Shift/Alt+Drag
          function isInteractive(el) {
            if (!el || el.nodeType !== 1) return false;
            const tag = (el.tagName || '').toUpperCase();
            if (['A','BUTTON','INPUT','SELECT','TEXTAREA','LABEL','FORM','SUMMARY'].includes(tag)) return true;
            if (el.hasAttribute && el.hasAttribute('contenteditable')) return true;
            const role = el.getAttribute ? (el.getAttribute('role') || '') : '';
            if (role === 'button' || role === 'link' || role === 'checkbox' || role === 'switch') return true;
            if (typeof el.onclick === 'function') return true;
            return false;
          }

          // Hover для drop target при перетаскивании (режим reparent)
          document.addEventListener('mousemove', (ev) => {
            if (!dragging || !dragging.sourceId || dragging.mode !== 'reparent') return;
            const el = ev.target && ev.target.closest ? ev.target.closest(SEL_ALL) : null;
            const sid = dragging.sourceId;
            if (el) {
              const id = ensureId(el);
              if (id && id !== sid) {
                dropTarget = id;
                post(MSG_DROP_TARGET, { sourceId: sid, targetId: id });
              }
            } else {
              dropTarget = null;
              post(MSG_DROP_TARGET, { sourceId: sid, targetId: null });
            }
          }, true);

          // Блокируем submit форм только в режиме редактора
          if (EDIT_MODE) {
            document.addEventListener('submit', (ev) => {
              try {
                ev.preventDefault();
                ev.stopPropagation();
                ev.stopImmediatePropagation();
              } catch(e) {}
            }, true);
          }

          // Блокируем все события на интерактивных элементах только в режиме редактора
          const blockInteractiveEvents = (ev) => {
            if (!EDIT_MODE) return;
            const t = ev.target;
            if (!t) return;
            // Проверяем, является ли элемент интерактивным
            if (isInteractive(t) || (t.closest && t.closest('a,button,input,select,textarea,label,form,[role=button],[role=link],[role=checkbox],[role=switch],[contenteditable]'))) {
              try {
                ev.preventDefault();
                ev.stopPropagation();
                ev.stopImmediatePropagation();
                // Если у интерактивного элемента есть id-атрибут, выбираем его напрямую
                if (t.hasAttribute && (t.hasAttribute(ATTR_NEW) || t.hasAttribute(ATTR_OLD))) {
                  selectEl(t);
                  return;
                }
                // Иначе выбираем родительский блок
                const block = t.closest(SEL_ALL);
                if (block && block !== t) {
                  selectEl(block);
                }
              } catch(e) {}
            }
          };

          // Блокируем все события на интерактивных элементах (кроме mousedown, который обрабатывается отдельно) только в режиме редактора
          if (EDIT_MODE) {
            document.addEventListener('mouseup', blockInteractiveEvents, true);
            document.addEventListener('dblclick', blockInteractiveEvents, true);
            document.addEventListener('change', blockInteractiveEvents, true);
            document.addEventListener('input', blockInteractiveEvents, true);
            document.addEventListener('focus', blockInteractiveEvents, true);
            document.addEventListener('blur', blockInteractiveEvents, true);
            document.addEventListener('keydown', (ev) => {
              const t = ev.target;
              if (t && (isInteractive(t) || (t.closest && t.closest('a,button,input,select,textarea,[role=button],[role=link],[contenteditable]')))) {
                try {
                  ev.preventDefault();
                  ev.stopPropagation();
                  ev.stopImmediatePropagation();
                  // Если у интерактивного элемента есть id-атрибут, выбираем его напрямую
                  if (t.hasAttribute && (t.hasAttribute(ATTR_NEW) || t.hasAttribute(ATTR_OLD))) {
                    selectEl(t);
                    return;
                  }
                  // Иначе выбираем родительский блок
                  const block = t.closest(SEL_ALL);
                  if (block && block !== t) {
                    selectEl(block);
                  }
                } catch(e) {}
              }
            }, true);
            document.addEventListener('keyup', blockInteractiveEvents, true);
            document.addEventListener('keypress', blockInteractiveEvents, true);
          }
          
          // Обработка клика для выбора блоков (только в режиме редактора)
          document.addEventListener('click', (ev) => {
            if (!EDIT_MODE) return; // В preview режиме не обрабатываем клики для выбора
            
            const t = ev.target;
            // Если это интерактивный элемент, обрабатываем его
            if (t && (isInteractive(t) || (t.closest && t.closest('a,button,input,select,textarea,label,form,[role=button],[role=link],[contenteditable]')))) {
              try {
                ev.preventDefault();
                ev.stopPropagation();
                ev.stopImmediatePropagation();
                // Если у интерактивного элемента есть id-атрибут, выбираем его напрямую
                if (t.hasAttribute && (t.hasAttribute(ATTR_NEW) || t.hasAttribute(ATTR_OLD))) {
                  selectEl(t);
                  return;
                }
                // Иначе выбираем родительский блок
                const block = t.closest(SEL_ALL);
                if (block && block !== t) {
                  selectEl(block);
                  return;
                }
              } catch(e) {}
            }
            // Если это не интерактивный элемент, обрабатываем как обычный клик для выбора блока
            const el = ev.target && ev.target.closest ? ev.target.closest(SEL_ALL) : null;
            if (!el) return;
            try {
              ev.preventDefault();
              ev.stopPropagation();
            } catch(e) {}
            selectEl(el);
          }, true);

          // Shift+Drag: перенос (MVP -> position:absolute + left/top/width/height)
          // Этот обработчик также блокирует интерактивные элементы (только в режиме редактора)
          let drag = null;
          document.addEventListener('mousedown', (ev) => {
            if (!EDIT_MODE) return; // В preview режиме не обрабатываем
            
            const t = ev.target;
            // Если это интерактивный элемент, обрабатываем его
            if (t && (isInteractive(t) || (t.closest && t.closest('a,button,input,select,textarea,label,form,[role=button],[role=link],[contenteditable]')))) {
              try {
                ev.preventDefault();
                ev.stopPropagation();
                ev.stopImmediatePropagation();
                
                // Если у интерактивного элемента есть id-атрибут, используем его
                let targetEl = t;
                let targetId = null;
                if (t.hasAttribute && (t.hasAttribute(ATTR_NEW) || t.hasAttribute(ATTR_OLD))) {
                  targetId = getId(t);
                } else {
                  // Иначе ищем родительский блок
                  const block = t.closest(SEL_ALL);
                  if (block && block !== t) {
                    targetEl = block;
                    targetId = getId(block);
                  }
                }
                
                if (targetId) {
                  selectEl(targetEl);
                  // Если это Shift/Ctrl/Alt + клик, обрабатываем как drag
                  if (ev.ctrlKey || ev.metaKey) {
                    dragging = { sourceId: targetId, mode: 'reparent' };
                    post(MSG_DROP_TARGET, { sourceId: targetId, targetId: null });
                    return;
                  } else if (ev.shiftKey || ev.altKey) {
                    dragging = { sourceId: targetId, mode: ev.altKey ? 'resize' : 'move' };
                    const startRect = targetEl.getBoundingClientRect();
                    drag = {
                      mode: ev.altKey ? 'resize' : 'move',
                      sx: ev.clientX,
                      sy: ev.clientY,
                      rect: startRect,
                    };
                    return;
                  }
                }
                return;
              } catch(e) {}
            }
            
            const el = ev.target && ev.target.closest ? ev.target.closest(SEL_ALL) : null;
            if (!el) return;
            
            // Ctrl/Cmd + drag => reparent drag
            if (ev.ctrlKey || ev.metaKey) {
              ev.preventDefault();
              ev.stopPropagation();
              const id = ensureId(el);
              dragging = { sourceId: id, mode: 'reparent' };
              selectEl(el);
              post(MSG_DROP_TARGET, { sourceId: id, targetId: null });
              return;
            }
            if (!selected) return;
            if (!ev.shiftKey && !ev.altKey) return;
            ev.preventDefault();
            ev.stopPropagation();
            const id = ensureId(selected);
            dragging = { sourceId: id, mode: ev.altKey ? 'resize' : 'move' };
            const startRect = selected.getBoundingClientRect();
            drag = {
              mode: ev.altKey ? 'resize' : 'move',
              sx: ev.clientX,
              sy: ev.clientY,
              rect: startRect,
            };
          }, true);

          document.addEventListener('mousemove', (ev) => {
            if (!drag || !selected) return;
            const dx = ev.clientX - drag.sx;
            const dy = ev.clientY - drag.sy;
            const id = ensureId(selected);
            
            if (drag.mode === 'move') {
              selected.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
              
              // Отправляем промежуточные изменения при каждом движении
              const parent = getOffsetParent(selected);
              const parentRect = parent && parent.getBoundingClientRect ? parent.getBoundingClientRect() : { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight };
              const ps = parent ? window.getComputedStyle(parent) : null;
              const padLeft = ps ? parseFloat(ps.getPropertyValue('padding-left')) || 0 : 0;
              const padTop = ps ? parseFloat(ps.getPropertyValue('padding-top')) || 0 : 0;
              const padRight = ps ? parseFloat(ps.getPropertyValue('padding-right')) || 0 : 0;
              const padBottom = ps ? parseFloat(ps.getPropertyValue('padding-bottom')) || 0 : 0;
              
              if (moveMode === 'relative') {
                const cs = window.getComputedStyle(selected);
                const baseLeft = cs.left === 'auto' ? 0 : pxToNum(cs.left);
                const baseTop = cs.top === 'auto' ? 0 : pxToNum(cs.top);
                const left = snap(baseLeft + dx);
                const top = snap(baseTop + dy);
                
                if ('react' === 'html') {
                  post(MSG_APPLY, { id, patch: { position: 'relative', left: left + 'px', top: top + 'px' }, isIntermediate: true });
                } else {
                  post(MSG_APPLY, { id, patch: { position: 'relative', left: left, top: top }, isIntermediate: true });
                }
              } else {
                const startLeft = drag.rect.left - parentRect.left - padLeft;
                const startTop = drag.rect.top - parentRect.top - padTop;
                
                let left = snap(startLeft + dx);
                let top = snap(startTop + dy);
                
                const maxLeft = parentRect.width - padRight - snap(drag.rect.width);
                const maxTop = parentRect.height - padBottom - snap(drag.rect.height);
                const minLeft = padLeft;
                const minTop = padTop;
                left = Math.min(Math.max(left, minLeft), maxLeft);
                top = Math.min(Math.max(top, minTop), maxTop);
                
                if ('react' === 'html') {
                  post(MSG_APPLY, { id, patch: { position: 'absolute', left: left + 'px', top: top + 'px' }, isIntermediate: true });
                } else {
                  post(MSG_APPLY, { id, patch: { position: 'absolute', left: left, top: top }, isIntermediate: true });
                }
              }
            } else {
              const w = snap(Math.max(1, drag.rect.width + dx));
              const h = snap(Math.max(1, drag.rect.height + dy));
              selected.style.width = w + 'px';
              selected.style.height = h + 'px';
              
              // Отправляем промежуточные изменения при каждом движении
              if ('react' === 'html') {
                post(MSG_APPLY, { id, patch: { width: w + 'px', height: h + 'px' }, isIntermediate: true });
              } else {
                post(MSG_APPLY, { id, patch: { width: w, height: h }, isIntermediate: true });
              }
            }
          }, true);

          // Touch события для мобильных устройств
          document.addEventListener('touchmove', (ev) => {
            if (!drag || !selected) return;
            const touch = ev.touches[0];
            if (!touch) return;
            const dx = touch.clientX - drag.sx;
            const dy = touch.clientY - drag.sy;
            const id = ensureId(selected);
            
            if (drag.mode === 'move') {
              selected.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
              
              // Отправляем промежуточные изменения при каждом движении
              const parent = getOffsetParent(selected);
              const parentRect = parent && parent.getBoundingClientRect ? parent.getBoundingClientRect() : { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight };
              const ps = parent ? window.getComputedStyle(parent) : null;
              const padLeft = ps ? parseFloat(ps.getPropertyValue('padding-left')) || 0 : 0;
              const padTop = ps ? parseFloat(ps.getPropertyValue('padding-top')) || 0 : 0;
              const padRight = ps ? parseFloat(ps.getPropertyValue('padding-right')) || 0 : 0;
              const padBottom = ps ? parseFloat(ps.getPropertyValue('padding-bottom')) || 0 : 0;
              
              if (moveMode === 'relative') {
                const cs = window.getComputedStyle(selected);
                const baseLeft = cs.left === 'auto' ? 0 : pxToNum(cs.left);
                const baseTop = cs.top === 'auto' ? 0 : pxToNum(cs.top);
                const left = snap(baseLeft + dx);
                const top = snap(baseTop + dy);
                
                if ('react' === 'html') {
                  post(MSG_APPLY, { id, patch: { position: 'relative', left: left + 'px', top: top + 'px' }, isIntermediate: true });
                } else {
                  post(MSG_APPLY, { id, patch: { position: 'relative', left: left, top: top }, isIntermediate: true });
                }
              } else {
                const startLeft = drag.rect.left - parentRect.left - padLeft;
                const startTop = drag.rect.top - parentRect.top - padTop;
                
                let left = snap(startLeft + dx);
                let top = snap(startTop + dy);
                
                const maxLeft = parentRect.width - padRight - snap(drag.rect.width);
                const maxTop = parentRect.height - padBottom - snap(drag.rect.height);
                const minLeft = padLeft;
                const minTop = padTop;
                left = Math.min(Math.max(left, minLeft), maxLeft);
                top = Math.min(Math.max(top, minTop), maxTop);
                
                if ('react' === 'html') {
                  post(MSG_APPLY, { id, patch: { position: 'absolute', left: left + 'px', top: top + 'px' }, isIntermediate: true });
                } else {
                  post(MSG_APPLY, { id, patch: { position: 'absolute', left: left, top: top }, isIntermediate: true });
                }
              }
            } else {
              const w = snap(Math.max(1, drag.rect.width + dx));
              const h = snap(Math.max(1, drag.rect.height + dy));
              selected.style.width = w + 'px';
              selected.style.height = h + 'px';
              
              // Отправляем промежуточные изменения при каждом движении
              if ('react' === 'html') {
                post(MSG_APPLY, { id, patch: { width: w + 'px', height: h + 'px' }, isIntermediate: true });
              } else {
                post(MSG_APPLY, { id, patch: { width: w, height: h }, isIntermediate: true });
              }
            }
          }, { passive: false });

          document.addEventListener('mouseup', (ev) => {
            // reparent drag (Ctrl/Cmd + drag)
            if (dragging && dragging.mode === 'reparent') {
              if (dropTarget && dragging.sourceId && dropTarget !== dragging.sourceId) {
                post(MSG_APPLY, { id: dragging.sourceId, patch: { __reparentTo: dropTarget } });
              }
              dragging = null;
              dropTarget = null;
              drag = null;
              return;
            }

            if (!drag || !selected) return;
            const dx = ev.clientX - drag.sx;
            const dy = ev.clientY - drag.sy;
            const id = ensureId(selected);

            // координаты родителя и padding для ограничения
            const parent = getOffsetParent(selected);
            const parentRect = parent && parent.getBoundingClientRect ? parent.getBoundingClientRect() : { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight };
            const ps = parent ? window.getComputedStyle(parent) : null;
            const padLeft = ps ? parseFloat(ps.getPropertyValue('padding-left')) || 0 : 0;
            const padTop = ps ? parseFloat(ps.getPropertyValue('padding-top')) || 0 : 0;
            const padRight = ps ? parseFloat(ps.getPropertyValue('padding-right')) || 0 : 0;
            const padBottom = ps ? parseFloat(ps.getPropertyValue('padding-bottom')) || 0 : 0;
            const scrollLeft = parent ? (parent.scrollLeft || 0) : 0;
            const scrollTop = parent ? (parent.scrollTop || 0) : 0;

            if (drag.mode === 'move') {
              selected.style.transform = '';

              if (moveMode === 'relative') {
                const cs = window.getComputedStyle(selected);
                const baseLeft = cs.left === 'auto' ? 0 : pxToNum(cs.left);
                const baseTop = cs.top === 'auto' ? 0 : pxToNum(cs.top);
                const left = snap(baseLeft + dx);
                const top = snap(baseTop + dy);
                selected.style.position = 'relative';
                selected.style.left = left + 'px';
                selected.style.top = top + 'px';

                if ('react' === 'html') {
                  post(MSG_APPLY, { id, patch: { position: 'relative', left: left + 'px', top: top + 'px' }, isIntermediate: false });
                } else {
                  post(MSG_APPLY, { id, patch: { position: 'relative', left: left, top: top }, isIntermediate: false });
                }
              } else {
                // absolute с ограничением по padding-box
                const startLeft = drag.rect.left - parentRect.left - padLeft;
                const startTop = drag.rect.top - parentRect.top - padTop;
                
                let left = snap(startLeft + dx);
                let top = snap(startTop + dy);

                // Ограничиваем позицию padding-box родителя
                const maxLeft = parentRect.width - padRight - snap(drag.rect.width);
                const maxTop = parentRect.height - padBottom - snap(drag.rect.height);
                const minLeft = padLeft;
                const minTop = padTop;
                left = Math.min(Math.max(left, minLeft), maxLeft);
                top = Math.min(Math.max(top, minTop), maxTop);

                selected.style.position = 'absolute';
                selected.style.left = left + 'px';
                selected.style.top = top + 'px';

                if ('react' === 'html') {
                  post(MSG_APPLY, { id, patch: { position: 'absolute', left: left + 'px', top: top + 'px' }, isIntermediate: false });
                } else {
                  post(MSG_APPLY, { id, patch: { position: 'absolute', left: left, top: top }, isIntermediate: false });
                }
              }
            } else {
              const w = snap(Math.max(1, drag.rect.width + dx));
              const h = snap(Math.max(1, drag.rect.height + dy));
              // constrain size чтобы не выходить за padding-box справа/снизу
              const maxW = parentRect.width - padLeft - padRight;
              const maxH = parentRect.height - padTop - padBottom;
              const cw = Math.min(w, maxW);
              const ch = Math.min(h, maxH);

              selected.style.width = cw + 'px';
              selected.style.height = ch + 'px';
              if ('react' === 'html') {
                post(MSG_APPLY, { id, patch: { width: cw + 'px', height: ch + 'px' }, isIntermediate: false });
              } else {
                post(MSG_APPLY, { id, patch: { width: cw, height: ch }, isIntermediate: false });
              }
            }

            drag = null;
            dragging = null;
            dropTarget = null;
          }, true);

          // Подсказка
          try {
            const hint = document.createElement('div');
            hint.className = 'mrpak-hint';
            hint.textContent = 'MRPAK Editor: клик = выбрать, Shift+Drag = переместить, Alt+Drag = изменить размер';
            document.body.appendChild(hint);
          } catch(e) {}

          // Команды из UI (локальные изменения)
          window.addEventListener('message', (event) => {
            const data = event && event.data;
            if (!data || typeof data !== 'object') return;
            try {
              if (data.type === CMD_SELECT && data.id) {
                const el = document.querySelector(byIdSelector(String(data.id)));
                if (el) selectEl(el);
                return;
              }
              if (data.type === CMD_SET_STYLE && data.id) {
                console.log('[iframe CMD_SET_STYLE] Получена команда:', {
                  id: data.id,
                  patch: data.patch,
                  hasPatch: !!data.patch
                });
                const el = document.querySelector(byIdSelector(String(data.id)));
                if (!el) {
                  console.warn('[iframe CMD_SET_STYLE] Элемент не найден:', data.id);
                  return;
                }
                const patch = data.patch || {};
                console.log('[iframe CMD_SET_STYLE] Применяю патч:', patch);
                for (const k in patch) {
                  const v = patch[k];
                  if (k.includes('-')) {
                    if (v === null || v === undefined || v === '') {
                      // Удаляем свойство, если значение пустое
                      el.style.removeProperty(k);
                    } else {
                      el.style.setProperty(k, String(v));
                    }
                  } else {
                    // DOM style: camelCase
                    try { 
                      if (v === null || v === undefined || v === '') {
                        el.style[k] = '';
                      } else {
                        el.style[k] = String(v);
                      }
                    } catch(e) {}
                  }
                }
                console.log('[iframe CMD_SET_STYLE] Стили применены, текущий style:', el.getAttribute('style'));
                
                // Перестроим дерево после изменения стилей
                buildTree();
                
                // обновим снапшот
                try {
                  const cs = window.getComputedStyle(el);
                  post(MSG_STYLE_SNAPSHOT, {
                    id: data.id,
                    inlineStyle: el.getAttribute('style') || '',
                    computedStyle: {
                      position: cs.getPropertyValue('position'),
                      left: cs.getPropertyValue('left'),
                      top: cs.getPropertyValue('top'),
                      width: cs.getPropertyValue('width'),
                      height: cs.getPropertyValue('height'),
                      color: cs.getPropertyValue('color'),
                      backgroundColor: cs.getPropertyValue('background-color'),
                      fontSize: cs.getPropertyValue('font-size'),
                      display: cs.getPropertyValue('display'),
                    },
                  });
                } catch(e) {}
                return;
              }
              if (data.type === CMD_REQ_STYLE && data.id) {
                const el = document.querySelector(byIdSelector(String(data.id)));
                if (!el) return;
                const cs = window.getComputedStyle(el);
                post(MSG_STYLE_SNAPSHOT, {
                  id: data.id,
                  inlineStyle: el.getAttribute('style') || '',
                  computedStyle: {
                    position: cs.getPropertyValue('position'),
                    left: cs.getPropertyValue('left'),
                    top: cs.getPropertyValue('top'),
                    width: cs.getPropertyValue('width'),
                    height: cs.getPropertyValue('height'),
                    color: cs.getPropertyValue('color'),
                    backgroundColor: cs.getPropertyValue('background-color'),
                    fontSize: cs.getPropertyValue('font-size'),
                    display: cs.getPropertyValue('display'),
                  },
                });
                return;
              }
              if (data.type === CMD_SET_TEXT && data.id) {
                const el = document.querySelector(byIdSelector(String(data.id)));
                if (!el) return;
                el.innerText = data.text ?? '';
                post(MSG_TEXT_SNAPSHOT, { id: data.id, text: el.innerText || '' });
                return;
              }
              if (data.type === CMD_REQ_TEXT && data.id) {
                const el = document.querySelector(byIdSelector(String(data.id)));
                if (!el) return;
                post(MSG_TEXT_SNAPSHOT, { id: data.id, text: el.innerText || '' });
                return;
              }
              if (data.type === CMD_DELETE && data.id) {
                const el = document.querySelector(byIdSelector(String(data.id)));
                if (el) {
                  if (selected === el) clearSelected();
                  el.remove();
                  buildTree();
                }
                return;
              }
              if (data.type === CMD_INSERT && data.targetId && data.mode && data.html) {
                console.log('[iframe CMD_INSERT] Получена команда вставки', {
                  targetId: data.targetId,
                  mode: data.mode,
                  htmlPreview: String(data.html).substring(0, 100)
                });
                const target = document.querySelector(byIdSelector(String(data.targetId)));
                if (!target) {
                  console.warn('[iframe CMD_INSERT] Target не найден!', data.targetId);
                  return;
                }
                const tmp = document.createElement('div');
                tmp.innerHTML = String(data.html);
                const newEl = tmp.firstElementChild;
                if (!newEl) {
                  console.warn('[iframe CMD_INSERT] Не удалось создать элемент из HTML');
                  return;
                }
                // временный id для дерева до commit
                const newElId = ensureId(newEl);
                console.log('[iframe CMD_INSERT] ✅ Вставляю элемент с ID:', newElId);
                if (data.mode === 'child') {
                  target.appendChild(newEl);
                } else if (data.mode === 'sibling') {
                  target.insertAdjacentElement('afterend', newEl);
                }
                buildTree();
                selectEl(newEl);
                return;
              }
              if (data.type === CMD_REPARENT && data.sourceId && data.targetParentId) {
                const srcEl = document.querySelector(byIdSelector(String(data.sourceId)));
                const dstEl = document.querySelector(byIdSelector(String(data.targetParentId)));
                if (srcEl && dstEl && srcEl !== dstEl) {
                  dstEl.appendChild(srcEl);
                  buildTree();
                  selectEl(srcEl);
                }
                return;
              }
              if (data.type === CMD_SET_MOVE_MODE) {
                if (data.mode) moveMode = String(data.mode);
                if (typeof data.grid === 'number') gridStep = data.grid;
                return;
              }
            } catch(e) {}
          }, false);

          post(MSG_READY, { meta: { mode: 'edit' } });
          buildTree();
        })();
      </script>
    

      <style>
        [data-no-code-ui-id].mrpak-selected, [data-mrpak-id].mrpak-selected { outline: 2px solid #667eea !important; outline-offset: 2px; }
        .mrpak-hint { position: fixed; z-index: 9999; bottom: 10px; right: 10px; background: rgba(15,23,42,0.85); color: #fff; padding: 8px 10px; border-radius: 8px; font: 12px/1.2 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif; }
        
        /* Блокируем интерактивные элементы только в режиме редактора */
        [data-no-code-ui-id] button,
        [data-no-code-ui-id] input,
        [data-no-code-ui-id] select,
        [data-no-code-ui-id] textarea,
        [data-no-code-ui-id] a,
        [data-no-code-ui-id] [role="button"],
        [data-no-code-ui-id] [role="link"],
        [data-no-code-ui-id] [contenteditable="true"],
        [data-no-code-ui-id] [contenteditable=""],
        [data-mrpak-id] button,
        [data-mrpak-id] input,
        [data-mrpak-id] select,
        [data-mrpak-id] textarea,
        [data-mrpak-id] a,
        [data-mrpak-id] [role="button"],
        [data-mrpak-id] [role="link"],
        [data-mrpak-id] [contenteditable="true"],
        [data-mrpak-id] [contenteditable=""] {
          pointer-events: none !important;
          user-select: none !important;
          -webkit-user-select: none !important;
          -moz-user-select: none !important;
          -ms-user-select: none !important;
        }
        /* Разрешаем pointer-events только для выбора блоков */
        [data-no-code-ui-id],
        [data-mrpak-id] {
          cursor: pointer;
        }
        
      </style>
      <script>
        (function() {
          const EDIT_MODE = true;
          const ATTR_NEW = 'data-no-code-ui-id';
          const ATTR_OLD = 'data-mrpak-id';
          const SEL_ALL = '[data-no-code-ui-id],[data-mrpak-id]';
          const getId = (el) => {
            try {
              return (el && el.getAttribute && (el.getAttribute(ATTR_NEW) || el.getAttribute(ATTR_OLD))) || null;
            } catch (e) {
              return null;
            }
          };
          const ensureId = (el) => {
            try {
              if (!el || !el.getAttribute || !el.setAttribute) return null;
              const id = getId(el);
              if (id) {
                if (!el.getAttribute(ATTR_NEW)) el.setAttribute(ATTR_NEW, id);
                if (el.getAttribute(ATTR_OLD)) el.removeAttribute(ATTR_OLD);
                return id;
              }
              const tmp = 'mrpak:temp:' + Date.now() + ':' + Math.random().toString(16).slice(2, 8);
              el.setAttribute(ATTR_NEW, tmp);
              return tmp;
            } catch (e) {
              return null;
            }
          };
          const byIdSelector = (id) => {
            const safe = String(id || '').replace(/"/g,'');
            return '[data-no-code-ui-id="' + safe + '"],[data-mrpak-id="' + safe + '"]';
          };
          const MSG_SELECT = 'MRPAK_SELECT';
          const MSG_APPLY = 'MRPAK_APPLY';
          const MSG_TREE = 'MRPAK_TREE';
          const MSG_READY = 'MRPAK_READY';
          const MSG_STYLE_SNAPSHOT = 'MRPAK_STYLE_SNAPSHOT';
          const MSG_TEXT_SNAPSHOT = 'MRPAK_TEXT_SNAPSHOT';
          const MSG_DROP_TARGET = 'MRPAK_DROP_TARGET';
          const CMD_SELECT = 'MRPAK_CMD_SELECT';
          const CMD_INSERT = 'MRPAK_CMD_INSERT';
          const CMD_DELETE = 'MRPAK_CMD_DELETE';
          const CMD_SET_STYLE = 'MRPAK_CMD_SET_STYLE';
          const CMD_REQ_STYLE = 'MRPAK_CMD_REQUEST_STYLE_SNAPSHOT';
          const CMD_REPARENT = 'MRPAK_CMD_REPARENT';
          const CMD_SET_MOVE_MODE = 'MRPAK_CMD_SET_MOVE_MODE';
          const CMD_SET_TEXT = 'MRPAK_CMD_SET_TEXT';
          const CMD_REQ_TEXT = 'MRPAK_CMD_REQUEST_TEXT_SNAPSHOT';
          const CMD_START_DRAG = 'MRPAK_CMD_START_DRAG';
          const CMD_END_DRAG = 'MRPAK_CMD_END_DRAG';
          let selected = null;
          let lastSelectedId = null;
          let moveMode = 'absolute'; // absolute | relative | grid8
          let gridStep = 8;
          let dragging = null; // {sourceId}
          let dropTarget = null;

          const snap = (v) => {
            if (moveMode !== 'grid8') return v;
            const step = gridStep || 8;
            return Math.round(v / step) * step;
          };

          const getOffsetParent = (el) => el && (el.offsetParent || el.parentElement || document.body);

          const pxToNum = (s) => {
            const m = String(s || '').match(/(-?\d+(?:\.\d+)?)px/);
            return m ? Number(m[1]) : 0;
          };

          function post(type, payload) {
            try {
              window.parent && window.parent.postMessage({ type, ...payload }, '*');
            } catch (e) {}
          }

          function buildTree() {
            const nodes = {};
            const rootIds = [];
            const all = Array.from(document.querySelectorAll(SEL_ALL));
            
            // Сначала создаем все узлы
            for (const el of all) {
              const id = ensureId(el);
              if (!id) continue;
              
              // Ищем родителя более точно: идем вверх по DOM дереву и ищем ближайший элемент с id-атрибутом
              let parentEl = null;
              let current = el.parentElement;
              while (current && current !== document.body && current !== document.documentElement) {
                if (current.hasAttribute && (current.hasAttribute(ATTR_NEW) || current.hasAttribute(ATTR_OLD))) {
                  parentEl = current;
                  break;
                }
                current = current.parentElement;
              }
              
              const parentId = parentEl ? getId(parentEl) : null;
              nodes[id] = { id, tagName: el.tagName, parentId, childIds: [] };
            }
            
            // Определяем детей и корневые элементы
            for (const id of Object.keys(nodes)) {
              const p = nodes[id].parentId;
              if (p && nodes[p]) {
                nodes[p].childIds.push(id);
              } else {
                rootIds.push(id);
              }
            }
            
            // Упорядочиваем children по порядку в DOM
            for (const id of Object.keys(nodes)) {
              const el = document.querySelector(byIdSelector(id));
              if (!el) continue;
              
              const parentEl = el.parentElement;
              if (parentEl) {
                // Ищем родителя с id-атрибутом
                let parentWithId = null;
                let current = parentEl;
                while (current && current !== document.body && current !== document.documentElement) {
                  if (current.hasAttribute && (current.hasAttribute(ATTR_NEW) || current.hasAttribute(ATTR_OLD))) {
                    parentWithId = current;
                    break;
                  }
                  current = current.parentElement;
                }
                
                if (parentWithId) {
                  const pid = ensureId(parentWithId);
                  if (pid && nodes[pid]) {
                    // Получаем прямых детей с id-атрибутом в порядке DOM
                    const directChildren = Array.from(parentWithId.children)
                      .filter(child => child && child.hasAttribute && (child.hasAttribute(ATTR_NEW) || child.hasAttribute(ATTR_OLD)))
                      .map(child => ensureId(child))
                      .filter(Boolean);
                    nodes[pid].childIds = directChildren;
                  }
                }
              }
            }
            
            post(MSG_TREE, { tree: { nodes, rootIds } });
          }
          
          // Делаем buildTree доступной глобально для вызова из скрипта React
          window.__MRPAK_BUILD_TREE__ = buildTree;

          function clearSelected() {
            try {
              if (selected) selected.classList.remove('mrpak-selected');
            } catch(e) {}
            selected = null;
          }

          function selectEl(el) {
            if (!el) return;
            clearSelected();
            selected = el;
            try { selected.classList.add('mrpak-selected'); } catch(e) {}
            const id = ensureId(selected);
            lastSelectedId = id;
            const rect = selected.getBoundingClientRect();
            post(MSG_SELECT, { id, meta: { tagName: selected.tagName, rect: { x: rect.x, y: rect.y, w: rect.width, h: rect.height } } });
            buildTree();
            // отправляем снапшот inline style, чтобы UI мог показать базовые стили
            try {
              const inline = selected.getAttribute('style') || '';
              const cs = window.getComputedStyle(selected);
              const computed = {
                position: cs.getPropertyValue('position'),
                left: cs.getPropertyValue('left'),
                top: cs.getPropertyValue('top'),
                width: cs.getPropertyValue('width'),
                height: cs.getPropertyValue('height'),
                color: cs.getPropertyValue('color'),
                backgroundColor: cs.getPropertyValue('background-color'),
                fontSize: cs.getPropertyValue('font-size'),
                display: cs.getPropertyValue('display'),
                flex: cs.getPropertyValue('flex'),
                justifyContent: cs.getPropertyValue('justify-content'),
                alignItems: cs.getPropertyValue('align-items'),
                margin: cs.getPropertyValue('margin'),
                padding: cs.getPropertyValue('padding'),
              };
              post(MSG_STYLE_SNAPSHOT, { id, inlineStyle: inline, computedStyle: computed });
              const txt = selected.innerText || '';
              post(MSG_TEXT_SNAPSHOT, { id, text: txt });
            } catch(e) {}
          }

          // В режиме редактора делаем контент "неинтерактивным":
          // - гасим клики/submit/клавиатурные активации по интерактивным элементам
          // - при этом сохраняем возможность выбирать блоки кликом и двигать Shift/Alt+Drag
          function isInteractive(el) {
            if (!el || el.nodeType !== 1) return false;
            const tag = (el.tagName || '').toUpperCase();
            if (['A','BUTTON','INPUT','SELECT','TEXTAREA','LABEL','FORM','SUMMARY'].includes(tag)) return true;
            if (el.hasAttribute && el.hasAttribute('contenteditable')) return true;
            const role = el.getAttribute ? (el.getAttribute('role') || '') : '';
            if (role === 'button' || role === 'link' || role === 'checkbox' || role === 'switch') return true;
            if (typeof el.onclick === 'function') return true;
            return false;
          }

          // Hover для drop target при перетаскивании (режим reparent)
          document.addEventListener('mousemove', (ev) => {
            if (!dragging || !dragging.sourceId || dragging.mode !== 'reparent') return;
            const el = ev.target && ev.target.closest ? ev.target.closest(SEL_ALL) : null;
            const sid = dragging.sourceId;
            if (el) {
              const id = ensureId(el);
              if (id && id !== sid) {
                dropTarget = id;
                post(MSG_DROP_TARGET, { sourceId: sid, targetId: id });
              }
            } else {
              dropTarget = null;
              post(MSG_DROP_TARGET, { sourceId: sid, targetId: null });
            }
          }, true);

          // Блокируем submit форм только в режиме редактора
          if (EDIT_MODE) {
            document.addEventListener('submit', (ev) => {
              try {
                ev.preventDefault();
                ev.stopPropagation();
                ev.stopImmediatePropagation();
              } catch(e) {}
            }, true);
          }

          // Блокируем все события на интерактивных элементах только в режиме редактора
          const blockInteractiveEvents = (ev) => {
            if (!EDIT_MODE) return;
            const t = ev.target;
            if (!t) return;
            // Проверяем, является ли элемент интерактивным
            if (isInteractive(t) || (t.closest && t.closest('a,button,input,select,textarea,label,form,[role=button],[role=link],[role=checkbox],[role=switch],[contenteditable]'))) {
              try {
                ev.preventDefault();
                ev.stopPropagation();
                ev.stopImmediatePropagation();
                // Если у интерактивного элемента есть id-атрибут, выбираем его напрямую
                if (t.hasAttribute && (t.hasAttribute(ATTR_NEW) || t.hasAttribute(ATTR_OLD))) {
                  selectEl(t);
                  return;
                }
                // Иначе выбираем родительский блок
                const block = t.closest(SEL_ALL);
                if (block && block !== t) {
                  selectEl(block);
                }
              } catch(e) {}
            }
          };

          // Блокируем все события на интерактивных элементах (кроме mousedown, который обрабатывается отдельно) только в режиме редактора
          if (EDIT_MODE) {
            document.addEventListener('mouseup', blockInteractiveEvents, true);
            document.addEventListener('dblclick', blockInteractiveEvents, true);
            document.addEventListener('change', blockInteractiveEvents, true);
            document.addEventListener('input', blockInteractiveEvents, true);
            document.addEventListener('focus', blockInteractiveEvents, true);
            document.addEventListener('blur', blockInteractiveEvents, true);
            document.addEventListener('keydown', (ev) => {
              const t = ev.target;
              if (t && (isInteractive(t) || (t.closest && t.closest('a,button,input,select,textarea,[role=button],[role=link],[contenteditable]')))) {
                try {
                  ev.preventDefault();
                  ev.stopPropagation();
                  ev.stopImmediatePropagation();
                  // Если у интерактивного элемента есть id-атрибут, выбираем его напрямую
                  if (t.hasAttribute && (t.hasAttribute(ATTR_NEW) || t.hasAttribute(ATTR_OLD))) {
                    selectEl(t);
                    return;
                  }
                  // Иначе выбираем родительский блок
                  const block = t.closest(SEL_ALL);
                  if (block && block !== t) {
                    selectEl(block);
                  }
                } catch(e) {}
              }
            }, true);
            document.addEventListener('keyup', blockInteractiveEvents, true);
            document.addEventListener('keypress', blockInteractiveEvents, true);
          }
          
          // Обработка клика для выбора блоков (только в режиме редактора)
          document.addEventListener('click', (ev) => {
            if (!EDIT_MODE) return; // В preview режиме не обрабатываем клики для выбора
            
            const t = ev.target;
            // Если это интерактивный элемент, обрабатываем его
            if (t && (isInteractive(t) || (t.closest && t.closest('a,button,input,select,textarea,label,form,[role=button],[role=link],[contenteditable]')))) {
              try {
                ev.preventDefault();
                ev.stopPropagation();
                ev.stopImmediatePropagation();
                // Если у интерактивного элемента есть id-атрибут, выбираем его напрямую
                if (t.hasAttribute && (t.hasAttribute(ATTR_NEW) || t.hasAttribute(ATTR_OLD))) {
                  selectEl(t);
                  return;
                }
                // Иначе выбираем родительский блок
                const block = t.closest(SEL_ALL);
                if (block && block !== t) {
                  selectEl(block);
                  return;
                }
              } catch(e) {}
            }
            // Если это не интерактивный элемент, обрабатываем как обычный клик для выбора блока
            const el = ev.target && ev.target.closest ? ev.target.closest(SEL_ALL) : null;
            if (!el) return;
            try {
              ev.preventDefault();
              ev.stopPropagation();
            } catch(e) {}
            selectEl(el);
          }, true);

          // Shift+Drag: перенос (MVP -> position:absolute + left/top/width/height)
          // Этот обработчик также блокирует интерактивные элементы (только в режиме редактора)
          let drag = null;
          document.addEventListener('mousedown', (ev) => {
            if (!EDIT_MODE) return; // В preview режиме не обрабатываем
            
            const t = ev.target;
            // Если это интерактивный элемент, обрабатываем его
            if (t && (isInteractive(t) || (t.closest && t.closest('a,button,input,select,textarea,label,form,[role=button],[role=link],[contenteditable]')))) {
              try {
                ev.preventDefault();
                ev.stopPropagation();
                ev.stopImmediatePropagation();
                
                // Если у интерактивного элемента есть id-атрибут, используем его
                let targetEl = t;
                let targetId = null;
                if (t.hasAttribute && (t.hasAttribute(ATTR_NEW) || t.hasAttribute(ATTR_OLD))) {
                  targetId = getId(t);
                } else {
                  // Иначе ищем родительский блок
                  const block = t.closest(SEL_ALL);
                  if (block && block !== t) {
                    targetEl = block;
                    targetId = getId(block);
                  }
                }
                
                if (targetId) {
                  selectEl(targetEl);
                  // Если это Shift/Ctrl/Alt + клик, обрабатываем как drag
                  if (ev.ctrlKey || ev.metaKey) {
                    dragging = { sourceId: targetId, mode: 'reparent' };
                    post(MSG_DROP_TARGET, { sourceId: targetId, targetId: null });
                    return;
                  } else if (ev.shiftKey || ev.altKey) {
                    dragging = { sourceId: targetId, mode: ev.altKey ? 'resize' : 'move' };
                    const startRect = targetEl.getBoundingClientRect();
                    drag = {
                      mode: ev.altKey ? 'resize' : 'move',
                      sx: ev.clientX,
                      sy: ev.clientY,
                      rect: startRect,
                    };
                    return;
                  }
                }
                return;
              } catch(e) {}
            }
            
            const el = ev.target && ev.target.closest ? ev.target.closest(SEL_ALL) : null;
            if (!el) return;
            
            // Ctrl/Cmd + drag => reparent drag
            if (ev.ctrlKey || ev.metaKey) {
              ev.preventDefault();
              ev.stopPropagation();
              const id = ensureId(el);
              dragging = { sourceId: id, mode: 'reparent' };
              selectEl(el);
              post(MSG_DROP_TARGET, { sourceId: id, targetId: null });
              return;
            }
            if (!selected) return;
            if (!ev.shiftKey && !ev.altKey) return;
            ev.preventDefault();
            ev.stopPropagation();
            const id = ensureId(selected);
            dragging = { sourceId: id, mode: ev.altKey ? 'resize' : 'move' };
            const startRect = selected.getBoundingClientRect();
            drag = {
              mode: ev.altKey ? 'resize' : 'move',
              sx: ev.clientX,
              sy: ev.clientY,
              rect: startRect,
            };
          }, true);

          document.addEventListener('mousemove', (ev) => {
            if (!drag || !selected) return;
            const dx = ev.clientX - drag.sx;
            const dy = ev.clientY - drag.sy;
            const id = ensureId(selected);
            
            if (drag.mode === 'move') {
              selected.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
              
              // Отправляем промежуточные изменения при каждом движении
              const parent = getOffsetParent(selected);
              const parentRect = parent && parent.getBoundingClientRect ? parent.getBoundingClientRect() : { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight };
              const ps = parent ? window.getComputedStyle(parent) : null;
              const padLeft = ps ? parseFloat(ps.getPropertyValue('padding-left')) || 0 : 0;
              const padTop = ps ? parseFloat(ps.getPropertyValue('padding-top')) || 0 : 0;
              const padRight = ps ? parseFloat(ps.getPropertyValue('padding-right')) || 0 : 0;
              const padBottom = ps ? parseFloat(ps.getPropertyValue('padding-bottom')) || 0 : 0;
              
              if (moveMode === 'relative') {
                const cs = window.getComputedStyle(selected);
                const baseLeft = cs.left === 'auto' ? 0 : pxToNum(cs.left);
                const baseTop = cs.top === 'auto' ? 0 : pxToNum(cs.top);
                const left = snap(baseLeft + dx);
                const top = snap(baseTop + dy);
                
                if ('react' === 'html') {
                  post(MSG_APPLY, { id, patch: { position: 'relative', left: left + 'px', top: top + 'px' }, isIntermediate: true });
                } else {
                  post(MSG_APPLY, { id, patch: { position: 'relative', left: left, top: top }, isIntermediate: true });
                }
              } else {
                const startLeft = drag.rect.left - parentRect.left - padLeft;
                const startTop = drag.rect.top - parentRect.top - padTop;
                
                let left = snap(startLeft + dx);
                let top = snap(startTop + dy);
                
                const maxLeft = parentRect.width - padRight - snap(drag.rect.width);
                const maxTop = parentRect.height - padBottom - snap(drag.rect.height);
                const minLeft = padLeft;
                const minTop = padTop;
                left = Math.min(Math.max(left, minLeft), maxLeft);
                top = Math.min(Math.max(top, minTop), maxTop);
                
                if ('react' === 'html') {
                  post(MSG_APPLY, { id, patch: { position: 'absolute', left: left + 'px', top: top + 'px' }, isIntermediate: true });
                } else {
                  post(MSG_APPLY, { id, patch: { position: 'absolute', left: left, top: top }, isIntermediate: true });
                }
              }
            } else {
              const w = snap(Math.max(1, drag.rect.width + dx));
              const h = snap(Math.max(1, drag.rect.height + dy));
              selected.style.width = w + 'px';
              selected.style.height = h + 'px';
              
              // Отправляем промежуточные изменения при каждом движении
              if ('react' === 'html') {
                post(MSG_APPLY, { id, patch: { width: w + 'px', height: h + 'px' }, isIntermediate: true });
              } else {
                post(MSG_APPLY, { id, patch: { width: w, height: h }, isIntermediate: true });
              }
            }
          }, true);

          // Touch события для мобильных устройств
          document.addEventListener('touchmove', (ev) => {
            if (!drag || !selected) return;
            const touch = ev.touches[0];
            if (!touch) return;
            const dx = touch.clientX - drag.sx;
            const dy = touch.clientY - drag.sy;
            const id = ensureId(selected);
            
            if (drag.mode === 'move') {
              selected.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
              
              // Отправляем промежуточные изменения при каждом движении
              const parent = getOffsetParent(selected);
              const parentRect = parent && parent.getBoundingClientRect ? parent.getBoundingClientRect() : { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight };
              const ps = parent ? window.getComputedStyle(parent) : null;
              const padLeft = ps ? parseFloat(ps.getPropertyValue('padding-left')) || 0 : 0;
              const padTop = ps ? parseFloat(ps.getPropertyValue('padding-top')) || 0 : 0;
              const padRight = ps ? parseFloat(ps.getPropertyValue('padding-right')) || 0 : 0;
              const padBottom = ps ? parseFloat(ps.getPropertyValue('padding-bottom')) || 0 : 0;
              
              if (moveMode === 'relative') {
                const cs = window.getComputedStyle(selected);
                const baseLeft = cs.left === 'auto' ? 0 : pxToNum(cs.left);
                const baseTop = cs.top === 'auto' ? 0 : pxToNum(cs.top);
                const left = snap(baseLeft + dx);
                const top = snap(baseTop + dy);
                
                if ('react' === 'html') {
                  post(MSG_APPLY, { id, patch: { position: 'relative', left: left + 'px', top: top + 'px' }, isIntermediate: true });
                } else {
                  post(MSG_APPLY, { id, patch: { position: 'relative', left: left, top: top }, isIntermediate: true });
                }
              } else {
                const startLeft = drag.rect.left - parentRect.left - padLeft;
                const startTop = drag.rect.top - parentRect.top - padTop;
                
                let left = snap(startLeft + dx);
                let top = snap(startTop + dy);
                
                const maxLeft = parentRect.width - padRight - snap(drag.rect.width);
                const maxTop = parentRect.height - padBottom - snap(drag.rect.height);
                const minLeft = padLeft;
                const minTop = padTop;
                left = Math.min(Math.max(left, minLeft), maxLeft);
                top = Math.min(Math.max(top, minTop), maxTop);
                
                if ('react' === 'html') {
                  post(MSG_APPLY, { id, patch: { position: 'absolute', left: left + 'px', top: top + 'px' }, isIntermediate: true });
                } else {
                  post(MSG_APPLY, { id, patch: { position: 'absolute', left: left, top: top }, isIntermediate: true });
                }
              }
            } else {
              const w = snap(Math.max(1, drag.rect.width + dx));
              const h = snap(Math.max(1, drag.rect.height + dy));
              selected.style.width = w + 'px';
              selected.style.height = h + 'px';
              
              // Отправляем промежуточные изменения при каждом движении
              if ('react' === 'html') {
                post(MSG_APPLY, { id, patch: { width: w + 'px', height: h + 'px' }, isIntermediate: true });
              } else {
                post(MSG_APPLY, { id, patch: { width: w, height: h }, isIntermediate: true });
              }
            }
          }, { passive: false });

          document.addEventListener('mouseup', (ev) => {
            // reparent drag (Ctrl/Cmd + drag)
            if (dragging && dragging.mode === 'reparent') {
              if (dropTarget && dragging.sourceId && dropTarget !== dragging.sourceId) {
                post(MSG_APPLY, { id: dragging.sourceId, patch: { __reparentTo: dropTarget } });
              }
              dragging = null;
              dropTarget = null;
              drag = null;
              return;
            }

            if (!drag || !selected) return;
            const dx = ev.clientX - drag.sx;
            const dy = ev.clientY - drag.sy;
            const id = ensureId(selected);

            // координаты родителя и padding для ограничения
            const parent = getOffsetParent(selected);
            const parentRect = parent && parent.getBoundingClientRect ? parent.getBoundingClientRect() : { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight };
            const ps = parent ? window.getComputedStyle(parent) : null;
            const padLeft = ps ? parseFloat(ps.getPropertyValue('padding-left')) || 0 : 0;
            const padTop = ps ? parseFloat(ps.getPropertyValue('padding-top')) || 0 : 0;
            const padRight = ps ? parseFloat(ps.getPropertyValue('padding-right')) || 0 : 0;
            const padBottom = ps ? parseFloat(ps.getPropertyValue('padding-bottom')) || 0 : 0;
            const scrollLeft = parent ? (parent.scrollLeft || 0) : 0;
            const scrollTop = parent ? (parent.scrollTop || 0) : 0;

            if (drag.mode === 'move') {
              selected.style.transform = '';

              if (moveMode === 'relative') {
                const cs = window.getComputedStyle(selected);
                const baseLeft = cs.left === 'auto' ? 0 : pxToNum(cs.left);
                const baseTop = cs.top === 'auto' ? 0 : pxToNum(cs.top);
                const left = snap(baseLeft + dx);
                const top = snap(baseTop + dy);
                selected.style.position = 'relative';
                selected.style.left = left + 'px';
                selected.style.top = top + 'px';

                if ('react' === 'html') {
                  post(MSG_APPLY, { id, patch: { position: 'relative', left: left + 'px', top: top + 'px' }, isIntermediate: false });
                } else {
                  post(MSG_APPLY, { id, patch: { position: 'relative', left: left, top: top }, isIntermediate: false });
                }
              } else {
                // absolute с ограничением по padding-box
                const startLeft = drag.rect.left - parentRect.left - padLeft;
                const startTop = drag.rect.top - parentRect.top - padTop;
                
                let left = snap(startLeft + dx);
                let top = snap(startTop + dy);

                // Ограничиваем позицию padding-box родителя
                const maxLeft = parentRect.width - padRight - snap(drag.rect.width);
                const maxTop = parentRect.height - padBottom - snap(drag.rect.height);
                const minLeft = padLeft;
                const minTop = padTop;
                left = Math.min(Math.max(left, minLeft), maxLeft);
                top = Math.min(Math.max(top, minTop), maxTop);

                selected.style.position = 'absolute';
                selected.style.left = left + 'px';
                selected.style.top = top + 'px';

                if ('react' === 'html') {
                  post(MSG_APPLY, { id, patch: { position: 'absolute', left: left + 'px', top: top + 'px' }, isIntermediate: false });
                } else {
                  post(MSG_APPLY, { id, patch: { position: 'absolute', left: left, top: top }, isIntermediate: false });
                }
              }
            } else {
              const w = snap(Math.max(1, drag.rect.width + dx));
              const h = snap(Math.max(1, drag.rect.height + dy));
              // constrain size чтобы не выходить за padding-box справа/снизу
              const maxW = parentRect.width - padLeft - padRight;
              const maxH = parentRect.height - padTop - padBottom;
              const cw = Math.min(w, maxW);
              const ch = Math.min(h, maxH);

              selected.style.width = cw + 'px';
              selected.style.height = ch + 'px';
              if ('react' === 'html') {
                post(MSG_APPLY, { id, patch: { width: cw + 'px', height: ch + 'px' }, isIntermediate: false });
              } else {
                post(MSG_APPLY, { id, patch: { width: cw, height: ch }, isIntermediate: false });
              }
            }

            drag = null;
            dragging = null;
            dropTarget = null;
          }, true);

          // Подсказка
          try {
            const hint = document.createElement('div');
            hint.className = 'mrpak-hint';
            hint.textContent = 'MRPAK Editor: клик = выбрать, Shift+Drag = переместить, Alt+Drag = изменить размер';
            document.body.appendChild(hint);
          } catch(e) {}

          // Команды из UI (локальные изменения)
          window.addEventListener('message', (event) => {
            const data = event && event.data;
            if (!data || typeof data !== 'object') return;
            try {
              if (data.type === CMD_SELECT && data.id) {
                const el = document.querySelector(byIdSelector(String(data.id)));
                if (el) selectEl(el);
                return;
              }
              if (data.type === CMD_SET_STYLE && data.id) {
                console.log('[iframe CMD_SET_STYLE] Получена команда:', {
                  id: data.id,
                  patch: data.patch,
                  hasPatch: !!data.patch
                });
                const el = document.querySelector(byIdSelector(String(data.id)));
                if (!el) {
                  console.warn('[iframe CMD_SET_STYLE] Элемент не найден:', data.id);
                  return;
                }
                const patch = data.patch || {};
                console.log('[iframe CMD_SET_STYLE] Применяю патч:', patch);
                for (const k in patch) {
                  const v = patch[k];
                  if (k.includes('-')) {
                    if (v === null || v === undefined || v === '') {
                      // Удаляем свойство, если значение пустое
                      el.style.removeProperty(k);
                    } else {
                      el.style.setProperty(k, String(v));
                    }
                  } else {
                    // DOM style: camelCase
                    try { 
                      if (v === null || v === undefined || v === '') {
                        el.style[k] = '';
                      } else {
                        el.style[k] = String(v);
                      }
                    } catch(e) {}
                  }
                }
                console.log('[iframe CMD_SET_STYLE] Стили применены, текущий style:', el.getAttribute('style'));
                
                // Перестроим дерево после изменения стилей
                buildTree();
                
                // обновим снапшот
                try {
                  const cs = window.getComputedStyle(el);
                  post(MSG_STYLE_SNAPSHOT, {
                    id: data.id,
                    inlineStyle: el.getAttribute('style') || '',
                    computedStyle: {
                      position: cs.getPropertyValue('position'),
                      left: cs.getPropertyValue('left'),
                      top: cs.getPropertyValue('top'),
                      width: cs.getPropertyValue('width'),
                      height: cs.getPropertyValue('height'),
                      color: cs.getPropertyValue('color'),
                      backgroundColor: cs.getPropertyValue('background-color'),
                      fontSize: cs.getPropertyValue('font-size'),
                      display: cs.getPropertyValue('display'),
                    },
                  });
                } catch(e) {}
                return;
              }
              if (data.type === CMD_REQ_STYLE && data.id) {
                const el = document.querySelector(byIdSelector(String(data.id)));
                if (!el) return;
                const cs = window.getComputedStyle(el);
                post(MSG_STYLE_SNAPSHOT, {
                  id: data.id,
                  inlineStyle: el.getAttribute('style') || '',
                  computedStyle: {
                    position: cs.getPropertyValue('position'),
                    left: cs.getPropertyValue('left'),
                    top: cs.getPropertyValue('top'),
                    width: cs.getPropertyValue('width'),
                    height: cs.getPropertyValue('height'),
                    color: cs.getPropertyValue('color'),
                    backgroundColor: cs.getPropertyValue('background-color'),
                    fontSize: cs.getPropertyValue('font-size'),
                    display: cs.getPropertyValue('display'),
                  },
                });
                return;
              }
              if (data.type === CMD_SET_TEXT && data.id) {
                const el = document.querySelector(byIdSelector(String(data.id)));
                if (!el) return;
                el.innerText = data.text ?? '';
                post(MSG_TEXT_SNAPSHOT, { id: data.id, text: el.innerText || '' });
                return;
              }
              if (data.type === CMD_REQ_TEXT && data.id) {
                const el = document.querySelector(byIdSelector(String(data.id)));
                if (!el) return;
                post(MSG_TEXT_SNAPSHOT, { id: data.id, text: el.innerText || '' });
                return;
              }
              if (data.type === CMD_DELETE && data.id) {
                const el = document.querySelector(byIdSelector(String(data.id)));
                if (el) {
                  if (selected === el) clearSelected();
                  el.remove();
                  buildTree();
                }
                return;
              }
              if (data.type === CMD_INSERT && data.targetId && data.mode && data.html) {
                console.log('[iframe CMD_INSERT] Получена команда вставки', {
                  targetId: data.targetId,
                  mode: data.mode,
                  htmlPreview: String(data.html).substring(0, 100)
                });
                const target = document.querySelector(byIdSelector(String(data.targetId)));
                if (!target) {
                  console.warn('[iframe CMD_INSERT] Target не найден!', data.targetId);
                  return;
                }
                const tmp = document.createElement('div');
                tmp.innerHTML = String(data.html);
                const newEl = tmp.firstElementChild;
                if (!newEl) {
                  console.warn('[iframe CMD_INSERT] Не удалось создать элемент из HTML');
                  return;
                }
                // временный id для дерева до commit
                const newElId = ensureId(newEl);
                console.log('[iframe CMD_INSERT] ✅ Вставляю элемент с ID:', newElId);
                if (data.mode === 'child') {
                  target.appendChild(newEl);
                } else if (data.mode === 'sibling') {
                  target.insertAdjacentElement('afterend', newEl);
                }
                buildTree();
                selectEl(newEl);
                return;
              }
              if (data.type === CMD_REPARENT && data.sourceId && data.targetParentId) {
                const srcEl = document.querySelector(byIdSelector(String(data.sourceId)));
                const dstEl = document.querySelector(byIdSelector(String(data.targetParentId)));
                if (srcEl && dstEl && srcEl !== dstEl) {
                  dstEl.appendChild(srcEl);
                  buildTree();
                  selectEl(srcEl);
                }
                return;
              }
              if (data.type === CMD_SET_MOVE_MODE) {
                if (data.mode) moveMode = String(data.mode);
                if (typeof data.grid === 'number') gridStep = data.grid;
                return;
              }
            } catch(e) {}
          }, false);

          post(MSG_READY, { meta: { mode: 'edit' } });
          buildTree();
        })();
      </script>
    
</body>
</html>
    :434
AstBidirectional.js:437 [AstBidirectional] All IDs found in AST: []
RenderFile.jsx:490 [applyBlockPatch] Failed to update codeAST: Element not found or no changes applied